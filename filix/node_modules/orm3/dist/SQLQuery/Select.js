"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectQuery = SelectQuery;
const Helpers = __importStar(require("./Helpers"));
const Where_1 = require("./Where");
const aggregateFunctions = [
    'ABS', 'CEIL', 'FLOOR', 'ROUND',
    'AVG', 'MIN', 'MAX',
    'LOG', 'LOG2', 'LOG10', 'EXP', 'POWER',
    'ACOS', 'ASIN', 'ATAN', 'COS', 'SIN', 'TAN',
    'CONV', 'RANDOM', 'RAND', 'RADIANS', 'DEGREES',
    'SUM', 'COUNT', 'DISTINCT'
];
function SelectQuery(dialect, opts = {}) {
    const sql = {
        from: [],
        where: [],
        order: [],
        group_by: null,
        found_rows: false,
        where_exists: false
    };
    const getTableAlias = (table) => {
        for (let i = 0; i < sql.from.length; i += 1) {
            if (sql.from[i].t === table) {
                return sql.from[i].a;
            }
        }
        return table;
    };
    let functionStack = [];
    let existsAliasCount = 0;
    const aggregateFun = (fun) => {
        return function aggregateFunction(...fnArgs) {
            if (fnArgs.length === 0) {
                functionStack.push(fun);
                return this;
            }
            let column = Array.prototype.slice.call(fnArgs);
            const alias = column.length > 1 && typeof column[column.length - 1] === 'string' ? column.pop() : null;
            if (column.length && Array.isArray(column[0])) {
                column = column[0].concat(column.slice(1));
            }
            return this.fun(fun, column.length && column[0] ? column : '*', alias);
        };
    };
    const builder = {
        select(fields) {
            if (fields) {
                if (!sql.from[sql.from.length - 1].select) {
                    sql.from[sql.from.length - 1].select = [];
                }
                const values = Array.isArray(fields) ? fields : Array.prototype.slice.call(arguments);
                sql.from[sql.from.length - 1].select = sql.from[sql.from.length - 1].select.concat(values);
            }
            return this;
        },
        calculateFoundRows() {
            sql.found_rows = true;
            return this;
        },
        as(alias) {
            const idx = sql.from.length - 1;
            if (sql.from[idx].select && sql.from[idx].select.length) {
                const idx2 = sql.from[idx].select.length - 1;
                if (typeof sql.from[idx].select[idx2] === 'string') {
                    sql.from[idx].select[idx2] = { c: sql.from[idx].select[idx2] };
                }
                sql.from[idx].select[sql.from[idx].select.length - 1].a = alias || null;
            }
            return this;
        },
        fun(fun, column, alias) {
            if (!Array.isArray(sql.from[sql.from.length - 1].select)) {
                sql.from[sql.from.length - 1].select = [];
            }
            sql.from[sql.from.length - 1].select.push({
                f: fun.toUpperCase(),
                c: column && column !== '*' ? column : null,
                a: alias || null,
                s: functionStack
            });
            functionStack = [];
            return this;
        },
        from(...args) {
            const table = args[0];
            const from = {
                t: table,
                a: `t${sql.from.length + 1}`
            };
            if (sql.from.length === 0) {
                sql.from.push(from);
                return this;
            }
            let f = args[1];
            let toTable = args[2];
            let toId = args[3];
            const last = args[args.length - 1];
            if (typeof last === 'object' && !Array.isArray(last)) {
                from.opts = args.pop();
            }
            let alias;
            let target;
            if (args.length === 3) {
                alias = sql.from[sql.from.length - 1].a;
                target = toTable;
            }
            else {
                alias = getTableAlias(toTable);
                target = toId;
            }
            from.j = [];
            if (f && f.length && target && target.length) {
                if (Array.isArray(f) && Array.isArray(target) && f.length === target.length) {
                    for (let i = 0; i < f.length; i += 1) {
                        from.j.push([f[i], alias, target[i]]);
                    }
                }
                else {
                    from.j.push([f, alias, target]);
                }
            }
            else {
                throw new Error('Invalid join definition');
            }
            sql.from.push(from);
            return this;
        },
        where(...args) {
            let whereClause = null;
            for (let i = 0; i < args.length; i += 1) {
                const arg = args[i];
                if (arg === null) {
                    continue;
                }
                if (typeof arg === 'string') {
                    if (whereClause !== null) {
                        sql.where.push(whereClause);
                    }
                    whereClause = {
                        t: getTableAlias(arg),
                        w: args[i + 1]
                    };
                    i += 1;
                }
                else {
                    if (whereClause !== null) {
                        sql.where.push(whereClause);
                    }
                    whereClause = {
                        t: null,
                        w: arg
                    };
                }
            }
            if (whereClause !== null) {
                sql.where.push(whereClause);
            }
            return this;
        },
        whereExists(table, tableLink, link, conditions) {
            existsAliasCount += 1;
            const alias = `texists${existsAliasCount}`;
            sql.where.push({
                t: sql.from.length ? sql.from[sql.from.length - 1].a : null,
                w: conditions,
                e: { t: table, tl: getTableAlias(tableLink), l: link, a: alias }
            });
            sql.where_exists = true;
            return this;
        },
        groupBy(...columns) {
            sql.group_by = columns;
            return this;
        },
        offset(offset) {
            sql.offset = offset;
            return this;
        },
        limit(limit) {
            sql.limit = limit;
            return this;
        },
        order(column, dir) {
            if (Array.isArray(dir)) {
                sql.order.push(Helpers.escapeQuery(dialect, column, dir));
            }
            else {
                sql.order.push({
                    c: Array.isArray(column) ? [getTableAlias(column[0]), column[1]] : column,
                    d: dir === 'Z' ? 'DESC' : 'ASC'
                });
            }
            return this;
        },
        build() {
            const query = [];
            const having = [];
            if (functionStack.length) {
                const pending = functionStack.pop();
                if (pending) {
                    this.fun(pending);
                }
            }
            query.push('SELECT');
            if (dialect.limitAsTop && Object.prototype.hasOwnProperty.call(sql, 'limit')) {
                query.push(`TOP ${sql.limit}`);
            }
            for (let i = 0; i < sql.from.length; i += 1) {
                sql.from[i].a = `t${i + 1}`;
            }
            const selectParts = [];
            for (let i = 0; i < sql.from.length; i += 1) {
                const fromEntry = sql.from[i];
                if (!fromEntry.select) {
                    continue;
                }
                for (let j = 0; j < fromEntry.select.length; j += 1) {
                    const selection = fromEntry.select[j];
                    if (typeof selection === 'string') {
                        if (sql.from.length === 1) {
                            selectParts.push(dialect.escapeId(selection));
                        }
                        else {
                            selectParts.push(dialect.escapeId(fromEntry.a, selection));
                        }
                        continue;
                    }
                    if (typeof selection === 'object') {
                        if (!selection.f && selection.c) {
                            if (sql.from.length === 1) {
                                selectParts.push(dialect.escapeId(selection.c));
                            }
                            else {
                                selectParts.push(dialect.escapeId(fromEntry.a, selection.c));
                            }
                            if (selection.a) {
                                selectParts[selectParts.length - 1] += ` AS ${dialect.escapeId(selection.a)}`;
                            }
                        }
                        if (selection.having) {
                            having.push(dialect.escapeId(selection.having));
                        }
                        if (selection.select) {
                            selectParts.push(dialect.escapeId(selection.select));
                            continue;
                        }
                    }
                    if (typeof selection === 'function') {
                        selectParts.push(selection(dialect));
                        continue;
                    }
                    let str = `${selection.f}(`;
                    if (selection.f) {
                        if (selection.c && !Array.isArray(selection.c)) {
                            selection.c = [selection.c];
                        }
                        if (Array.isArray(selection.c)) {
                            str += selection.c
                                .map((el) => {
                                if (!el) {
                                    return dialect.escapeVal(el);
                                }
                                if (typeof el.type === 'function') {
                                    switch (el.type()) {
                                        case 'text':
                                            return dialect.escapeVal(el.data, opts.timezone);
                                        default:
                                            return el;
                                    }
                                }
                                if (typeof el !== 'string') {
                                    return el;
                                }
                                if (sql.from.length === 1) {
                                    return dialect.escapeId(el);
                                }
                                return dialect.escapeId(fromEntry.a, el);
                            })
                                .join(', ');
                        }
                        else {
                            str += '*';
                        }
                        str += ')';
                    }
                    else if (selection.sql) {
                        str = `(${selection.sql})`;
                    }
                    else {
                        continue;
                    }
                    str += selection.a ? ` AS ${dialect.escapeId(selection.a)}` : '';
                    if (selection.s && selection.s.length > 0) {
                        str = `${selection.s.join('(')}(${str}${')'.repeat(selection.s.length + 1)})`;
                    }
                    selectParts.push(str);
                }
            }
            if (sql.found_rows) {
                query.push('SQL_CALC_FOUND_ROWS');
            }
            if (selectParts.length) {
                query.push(selectParts.join(', '));
            }
            else {
                query.push('*');
            }
            if (sql.from.length > 0) {
                query.push('FROM');
                if (sql.from.length > 2) {
                    query.push('('.repeat(sql.from.length - 2));
                }
                for (let i = 0; i < sql.from.length; i += 1) {
                    const fromEntry = sql.from[i];
                    if (i > 0) {
                        if (fromEntry.opts && fromEntry.opts.joinType) {
                            query.push(fromEntry.opts.joinType.toUpperCase());
                        }
                        query.push('JOIN');
                    }
                    if (sql.from.length === 1 && !sql.where_exists) {
                        query.push(dialect.escapeId(fromEntry.t));
                    }
                    else {
                        query.push(`${dialect.escapeId(fromEntry.t)} ${dialect.escapeId(fromEntry.a)}`);
                    }
                    if (i > 0 && fromEntry.j) {
                        query.push('ON');
                        for (let ii = 0; ii < fromEntry.j.length; ii += 1) {
                            if (ii > 0) {
                                query.push('AND');
                            }
                            query.push(`${dialect.escapeId(fromEntry.a, fromEntry.j[ii][0])} = ${dialect.escapeId(fromEntry.j[ii][1], fromEntry.j[ii][2])}`);
                        }
                        if (i < sql.from.length - 1) {
                            query.push(')');
                        }
                    }
                }
            }
            if (having.length > 0) {
                for (let i = 0; i < having.length; i += 1) {
                    query.push(`${i === 0 ? 'HAVING' : 'AND'}${having[i]}`);
                }
            }
            const whereClause = (0, Where_1.build)(dialect, sql.where, opts);
            if (Array.isArray(whereClause)) {
                query.push(...whereClause);
            }
            else if (whereClause) {
                query.push(whereClause);
            }
            if (sql.group_by !== null) {
                query.push(`GROUP BY ${sql.group_by
                    .map((column) => {
                    if (typeof column === 'string' && column[0] === '-') {
                        sql.order.unshift({ c: column.substr(1), d: 'DESC' });
                        return dialect.escapeId(column.substr(1));
                    }
                    return dialect.escapeId(column);
                })
                    .join(', ')}`);
            }
            if (sql.order.length > 0) {
                const orderParts = [];
                for (let i = 0; i < sql.order.length; i += 1) {
                    const ord = sql.order[i];
                    if (typeof ord === 'object') {
                        if (Array.isArray(ord.c)) {
                            orderParts.push(`${dialect.escapeId.apply(dialect, ord.c)} ${ord.d}`);
                        }
                        else {
                            orderParts.push(`${dialect.escapeId(ord.c)} ${ord.d}`);
                        }
                    }
                    else if (typeof ord === 'string') {
                        orderParts.push(ord);
                    }
                }
                if (orderParts.length > 0) {
                    query.push(`ORDER BY ${orderParts.join(', ')}`);
                }
            }
            if (!dialect.limitAsTop) {
                if (Object.prototype.hasOwnProperty.call(sql, 'limit')) {
                    if (Object.prototype.hasOwnProperty.call(sql, 'offset')) {
                        query.push(`LIMIT ${sql.limit} OFFSET ${sql.offset}`);
                    }
                    else {
                        query.push(`LIMIT ${sql.limit}`);
                    }
                }
                else if (Object.prototype.hasOwnProperty.call(sql, 'offset')) {
                    query.push(`OFFSET ${sql.offset}`);
                }
            }
            return query.join(' ');
        }
    };
    for (let i = 0; i < aggregateFunctions.length; i += 1) {
        const funName = aggregateFunctions[i].toLowerCase();
        builder[funName] = aggregateFun(aggregateFunctions[i]);
    }
    return builder;
}
//# sourceMappingURL=Select.js.map