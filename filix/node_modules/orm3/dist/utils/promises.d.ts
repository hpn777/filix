/**
 * Promise utilities for internal use during async migration
 *
 * These utilities help bridge callback-based and promise-based patterns
 * during the migration phase.
 */
/**
 * Convert a callback-based function to promise-based
 * Usage: const result = await callbackToPromise(fn, arg1, arg2, ...);
 */
export declare function callbackToPromise<T>(fn: (callback: (err: Error | null, result?: T) => void) => void): Promise<T>;
/**
 * Convert a void callback to promise
 * Usage: await callbackToPromiseVoid(fn, arg1, arg2, ...);
 */
export declare function callbackToPromiseVoid(fn: (callback: (err?: Error | null) => void) => void): Promise<void>;
/**
 * Execute an array of async operations in series
 * Usage: await eachSeries(items, async (item) => { ... });
 */
export declare function eachSeries<T>(items: T[], fn: (item: T, index: number) => Promise<void>): Promise<void>;
/**
 * Execute an array of async operations in parallel
 * Usage: await map(items, async (item) => { return process(item); });
 */
export declare function map<T, R>(items: T[], fn: (item: T, index: number) => Promise<R>): Promise<R[]>;
/**
 * Execute an operation with retry logic
 */
export declare function retry<T>(fn: () => Promise<T>, maxAttempts?: number, delayMs?: number): Promise<T>;
/**
 * Execute with timeout
 */
export declare function withTimeout<T>(promise: Promise<T>, timeoutMs: number, errorMessage?: string): Promise<T>;
/**
 * Convert a callback-based function to a promise-based function
 * This wraps a function that takes callbacks and returns a function that returns promises
 *
 * Usage:
 *   const asyncFind = promisify(driver.find.bind(driver));
 *   const result = await asyncFind(table, conditions);
 */
export declare function promisify<T extends any[], R>(fn: (...args: [...T, (err: Error | null, result?: R) => void]) => void): (...args: T) => Promise<R>;
/**
 * Convert a void callback-based function to a promise-based function
 * This wraps a function that takes callbacks and returns a function that returns promises
 *
 * Usage:
 *   const asyncRemove = promisifyVoid(driver.remove.bind(driver));
 *   await asyncRemove(table, conditions);
 */
export declare function promisifyVoid<T extends any[]>(fn: (...args: [...T, (err?: Error | null) => void]) => void): (...args: T) => Promise<void>;
declare const _default: {
    callbackToPromise: typeof callbackToPromise;
    callbackToPromiseVoid: typeof callbackToPromiseVoid;
    eachSeries: typeof eachSeries;
    map: typeof map;
    retry: typeof retry;
    withTimeout: typeof withTimeout;
    promisify: typeof promisify;
    promisifyVoid: typeof promisifyVoid;
};
export default _default;
//# sourceMappingURL=promises.d.ts.map