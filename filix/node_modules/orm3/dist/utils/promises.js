"use strict";
/**
 * Promise utilities for internal use during async migration
 *
 * These utilities help bridge callback-based and promise-based patterns
 * during the migration phase.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.callbackToPromise = callbackToPromise;
exports.callbackToPromiseVoid = callbackToPromiseVoid;
exports.eachSeries = eachSeries;
exports.map = map;
exports.retry = retry;
exports.withTimeout = withTimeout;
exports.promisify = promisify;
exports.promisifyVoid = promisifyVoid;
/**
 * Convert a callback-based function to promise-based
 * Usage: const result = await callbackToPromise(fn, arg1, arg2, ...);
 */
function callbackToPromise(fn) {
    return new Promise((resolve, reject) => {
        fn((err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        });
    });
}
/**
 * Convert a void callback to promise
 * Usage: await callbackToPromiseVoid(fn, arg1, arg2, ...);
 */
function callbackToPromiseVoid(fn) {
    return new Promise((resolve, reject) => {
        fn((err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
/**
 * Execute an array of async operations in series
 * Usage: await eachSeries(items, async (item) => { ... });
 */
async function eachSeries(items, fn) {
    for (let i = 0; i < items.length; i++) {
        await fn(items[i], i);
    }
}
/**
 * Execute an array of async operations in parallel
 * Usage: await map(items, async (item) => { return process(item); });
 */
async function map(items, fn) {
    return Promise.all(items.map((item, index) => fn(item, index)));
}
/**
 * Execute an operation with retry logic
 */
async function retry(fn, maxAttempts = 3, delayMs = 100) {
    let lastError = null;
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            return await fn();
        }
        catch (err) {
            lastError = err;
            if (attempt < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, delayMs * attempt));
            }
        }
    }
    throw lastError || new Error('Max retry attempts exceeded');
}
/**
 * Execute with timeout
 */
function withTimeout(promise, timeoutMs, errorMessage) {
    return Promise.race([
        promise,
        new Promise((_, reject) => setTimeout(() => reject(new Error(errorMessage || `Operation timed out after ${timeoutMs}ms`)), timeoutMs))
    ]);
}
/**
 * Convert a callback-based function to a promise-based function
 * This wraps a function that takes callbacks and returns a function that returns promises
 *
 * Usage:
 *   const asyncFind = promisify(driver.find.bind(driver));
 *   const result = await asyncFind(table, conditions);
 */
function promisify(fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            fn.apply(this, [...args,
                (err, result) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(result);
                    }
                }
            ]);
        });
    };
}
/**
 * Convert a void callback-based function to a promise-based function
 * This wraps a function that takes callbacks and returns a function that returns promises
 *
 * Usage:
 *   const asyncRemove = promisifyVoid(driver.remove.bind(driver));
 *   await asyncRemove(table, conditions);
 */
function promisifyVoid(fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            fn.apply(this, [...args,
                (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                }
            ]);
        });
    };
}
exports.default = {
    callbackToPromise,
    callbackToPromiseVoid,
    eachSeries,
    map,
    retry,
    withTimeout,
    promisify,
    promisifyVoid
};
//# sourceMappingURL=promises.js.map