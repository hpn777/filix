"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Validator_1 = __importDefault(require("./Validator"));
class Enforce {
    constructor(options) {
        this.validations = {};
        this.contexts = {};
        this.options = {
            returnAllErrors: Boolean(options && options.returnAllErrors)
        };
    }
    add(property, validator) {
        let normalized;
        if (typeof validator === 'function' && validator.length >= 2) {
            normalized = new Validator_1.default(validator);
        }
        else if (validator && typeof validator.validate === 'function') {
            normalized = validator;
        }
        else {
            throw new Error('Missing validator (function) in Enforce.add(property, validator)');
        }
        if (!Object.prototype.hasOwnProperty.call(this.validations, property)) {
            this.validations[property] = [];
        }
        this.validations[property].push(normalized);
        return this;
    }
    context(name, value) {
        if (typeof name === 'string' && arguments.length === 2) {
            this.contexts[name] = value;
            return this;
        }
        if (typeof name === 'string') {
            return this.contexts[name];
        }
        return this.contexts;
    }
    clear() {
        this.validations = {};
    }
    check(data, cb) {
        const queue = [];
        const errors = [];
        for (const property of Object.keys(this.validations)) {
            const validators = this.validations[property];
            for (const validator of validators) {
                queue.push({ property, validator });
            }
        }
        const next = () => {
            if (queue.length === 0) {
                if (errors.length > 0) {
                    if (this.options.returnAllErrors) {
                        cb(errors);
                    }
                    else {
                        cb(errors[0]);
                    }
                    return;
                }
                cb(null);
                return;
            }
            const { property, validator } = queue.shift();
            this.contexts.property = property;
            const handleResult = (message) => {
                if (message) {
                    const err = new Error(message);
                    err.property = property;
                    err.value = data[property];
                    err.msg = message;
                    err.type = 'validation';
                    if (!this.options.returnAllErrors) {
                        cb(err);
                        return;
                    }
                    errors.push(err);
                }
                next();
            };
            validator.validate(data[property], handleResult, data, this.contexts);
        };
        next();
    }
}
exports.default = Enforce;
//# sourceMappingURL=Enforce.js.map