"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Model;
const lodash_1 = __importDefault(require("lodash"));
const ChainFind_1 = __importDefault(require("./ChainFind"));
const Instance_1 = require("./Instance");
const LazyLoad_1 = __importDefault(require("./LazyLoad"));
const Error_1 = __importDefault(require("./Error"));
const OneAssociation = __importStar(require("./Associations/One"));
const ManyAssociation = __importStar(require("./Associations/Many"));
const ExtendAssociation = __importStar(require("./Associations/Extend"));
const Property_1 = __importDefault(require("./Property"));
const Hook = __importStar(require("./Hook"));
const Utilities = __importStar(require("./Utilities"));
const Validators_1 = __importDefault(require("./Validators/Validators"));
const Singleton_1 = __importDefault(require("./Singleton"));
const AvailableHooks = [
    "beforeCreate",
    "afterCreate",
    "beforeSave",
    "afterSave",
    "beforeValidation",
    "beforeRemove",
    "afterRemove",
    "afterLoad",
    "afterAutoFetch"
];
function Model(opts) {
    const one_associations = [];
    const many_associations = [];
    const extend_associations = [];
    const association_properties = [];
    const model_fields = [];
    const fieldToPropertyMap = {};
    const allProperties = {};
    const keyProperties = [];
    const modelHooks = {};
    // Initialize hooks from options
    if (opts.hooks) {
        for (const hook in opts.hooks) {
            if (opts.hooks.hasOwnProperty(hook)) {
                const hookFn = opts.hooks[hook];
                if (typeof hookFn === 'function') {
                    modelHooks[hook] = hookFn;
                }
            }
        }
    }
    const createHookHelper = function (hook) {
        return function (cb) {
            modelHooks[hook] = cb;
            return this;
        };
    };
    const assertNoCallback = (method, args) => {
        if (!args.length) {
            return;
        }
        const lastArg = args[args.length - 1];
        if (typeof lastArg === "function") {
            throw new TypeError(`${opts.table}.${method} no longer accepts callbacks. Await the returned promise instead.`);
        }
    };
    const createInstance = function (data, instanceOpts, cb) {
        instanceOpts = instanceOpts || {};
        const prepareInstance = (instance) => {
            // Hook execution is handled by Instance.ts saveInstance/waitHooks
            // No need to register event handlers here
            Hook.wait(instance, modelHooks.afterLoad, (err) => {
                if (err) {
                    return cb(err);
                }
                if (instanceOpts.extra) {
                    for (let i = 0; i < instanceOpts.extra.length; i++) {
                        if (!instanceOpts.extra[i].hasOwnProperty("extra")) {
                            continue;
                        }
                        for (const k in instanceOpts.extra[i].extra) {
                            instance[k] = instanceOpts.extra[i].extra[k];
                        }
                    }
                }
                if (instanceOpts.extra_info) {
                    instance.extra = instanceOpts.extra_info;
                }
                cb(null, instance);
            });
        };
        const saveNewInstance = (instance, saveCb) => {
            // Call instance.save directly - let it handle hooks
            instance.save({})
                .then(() => saveCb(null, instance))
                .catch((err) => cb(err));
        };
        const instance = (0, Instance_1.Instance)(model, {
            uid: instanceOpts.uid || undefined,
            data: data,
            autoSave: instanceOpts.autoSave,
            autoFetch: instanceOpts.autoFetch,
            autoFetchLimit: instanceOpts.autoFetchLimit,
            cascadeRemove: instanceOpts.cascadeRemove,
            extra: instanceOpts.extra,
            extra_info: instanceOpts.extra_info,
            driver: opts.driver,
            table: opts.table,
            keys: opts.keys,
            changes: (instanceOpts.is_new ? Object.keys(data) : []),
            validations: opts.validations || {},
            one_associations: one_associations,
            many_associations: many_associations,
            keyProperties: keyProperties,
            is_new: instanceOpts.is_new === true,
            setupAssociations: setupAssociations,
            hooks: modelHooks,
            methods: opts.methods || {}
        });
        const runAutoFetchAndPrepare = () => {
            const associationOptions = {
                autoFetch: instanceOpts.autoFetch,
                autoFetchLimit: instanceOpts.autoFetchLimit,
                cascadeRemove: instanceOpts.cascadeRemove
            };
            OneAssociation.autoFetch(instance, one_associations, associationOptions, () => {
                ManyAssociation.autoFetch(instance, many_associations, associationOptions, () => {
                    ExtendAssociation.autoFetch(instance, extend_associations, associationOptions, () => {
                        Hook.wait(instance, modelHooks.afterAutoFetch, (err) => {
                            if (err) {
                                return cb(err);
                            }
                            prepareInstance(instance);
                        });
                    });
                });
            });
        };
        if (instanceOpts.is_new && opts.autoSave) {
            return saveNewInstance(instance, function (err, inst) {
                if (err) {
                    return cb(err);
                }
                runAutoFetchAndPrepare();
            });
        }
        runAutoFetchAndPrepare();
    };
    const setupAssociations = (instance, inst_opts) => {
        const assoc_opts = {
            autoFetch: inst_opts?.autoFetch || false,
            autoFetchLimit: inst_opts?.autoFetchLimit,
            cascadeRemove: inst_opts?.cascadeRemove
        };
        OneAssociation.extend(model, instance, opts.driver, one_associations);
        ManyAssociation.extend(model, instance, opts.driver, many_associations, assoc_opts, createInstance);
        ExtendAssociation.extend(model, instance, opts.driver, extend_associations, assoc_opts);
        if (opts.properties) {
            LazyLoad_1.default.extend(instance, model, opts.properties);
        }
        if (opts.instanceMethods) {
            for (const m in opts.instanceMethods) {
                if (!instance.hasOwnProperty(m)) {
                    instance[m] = opts.instanceMethods[m];
                }
            }
        }
    };
    const model = function (...args) {
        // Check if called with 'new'
        if (this && this.constructor === model) {
            const data = args[0] || {};
            const instance = (0, Instance_1.Instance)(model, {
                uid: undefined,
                data: data,
                autoSave: opts.autoSave,
                autoFetch: opts.autoFetch,
                autoFetchLimit: opts.autoFetchLimit,
                cascadeRemove: opts.cascadeRemove,
                extra: undefined,
                extra_info: undefined,
                driver: opts.driver,
                table: opts.table,
                keys: opts.keys,
                changes: Object.keys(data),
                validations: opts.validations || {},
                one_associations: one_associations,
                many_associations: many_associations,
                keyProperties: keyProperties,
                is_new: true,
                setupAssociations: setupAssociations,
                hooks: modelHooks,
                methods: opts.methods || {}
            });
            return instance;
        }
        const cb = (typeof args[args.length - 1] === "function" ? args.pop() : null);
        if (args.length === 0) {
            createInstance({}, {}, function (err, instance) {
                if (cb)
                    cb(err, instance);
            });
            return model;
        }
        if (typeof args[0] === "object" && !Array.isArray(args[0])) {
            return model.find(args[0], cb);
        }
        // If we have a callback, call model.get to fetch from database
        if (cb) {
            return model.get.apply(model, args.concat([cb]));
        }
        // If no callback, create a shell instance with the provided key
        const shellData = {};
        const keyFieldNames = opts.keys || [];
        for (let i = 0; i < keyFieldNames.length && i < args.length; i++) {
            shellData[keyFieldNames[i]] = args[i];
        }
        // Create shell instance synchronously
        const instance = (0, Instance_1.Instance)(model, {
            uid: undefined,
            data: shellData,
            autoSave: false,
            autoFetch: undefined,
            autoFetchLimit: undefined,
            cascadeRemove: undefined,
            extra: undefined,
            extra_info: undefined,
            driver: opts.driver,
            table: opts.table,
            keys: opts.keys,
            changes: [],
            validations: opts.validations || {},
            one_associations: one_associations,
            many_associations: many_associations,
            keyProperties: keyProperties,
            is_new: false,
            isShell: true,
            setupAssociations: setupAssociations,
            hooks: modelHooks,
            methods: {}
        });
        return instance;
    };
    // Set model.settings early so Instance() can access it
    Object.defineProperty(model, "settings", {
        value: opts.settings,
        enumerable: false
    });
    Object.defineProperty(model, "table", {
        value: opts.table,
        enumerable: false
    });
    model.drop = async function () {
        assertNoCallback("drop", Array.from(arguments));
        await new Promise((resolve, reject) => {
            opts.driver.drop({
                table: opts.table,
                properties: allProperties,
                one_associations: one_associations,
                many_associations: many_associations
            }, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    };
    model.sync = async function () {
        assertNoCallback("sync", Array.from(arguments));
        await new Promise((resolve, reject) => {
            opts.driver.sync({
                id: keyProperties.map(p => p.name),
                extension: opts.extension,
                table: opts.table,
                allProperties: allProperties,
                one_associations: one_associations,
                many_associations: many_associations,
                extend_associations: extend_associations
            }, (err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    };
    model.get = function (...params) {
        assertNoCallback("get", params);
        const conditions = {};
        const options = {};
        const keys = Array.isArray(opts.keys) ? opts.keys : [opts.keys];
        let ids = params.slice();
        if (ids.length > 0 && typeof ids[ids.length - 1] === "object" && !Array.isArray(ids[ids.length - 1])) {
            const lastArg = ids[ids.length - 1];
            const hasIdFields = keys.some((k) => Object.prototype.hasOwnProperty.call(lastArg, k));
            if (!hasIdFields && ids.length > 1) {
                const optsArg = ids.pop();
                for (const k in optsArg) {
                    options[k] = optsArg[k];
                }
            }
        }
        if (ids.length === 1 && typeof ids[0] === "object" && !Array.isArray(ids[0])) {
            options.identityCache = ids[0].identityCache;
            delete ids[0].identityCache;
            for (const k in ids[0]) {
                if (keys.indexOf(k) !== -1) {
                    conditions[k] = ids[0][k];
                }
                else {
                    options[k] = ids[0][k];
                }
            }
        }
        else {
            if (keys.length === 1 && Array.isArray(ids[0])) {
                ids = ids[0];
            }
            if (ids.length !== keys.length) {
                throw new Error_1.default("Model.get() IDs missing", 'MISSING_CALLBACK', { model: opts.table });
            }
            for (let i = 0; i < keys.length; i++) {
                conditions[keys[i]] = ids[i];
            }
        }
        options.identityCache = options.hasOwnProperty("identityCache") ? options.identityCache : opts.settings.get("instance.identityCache");
        return new Promise((resolve, reject) => {
            const uid = opts.driver.uid + "/" + opts.table + "/";
            const itemId = uid + keys.map((k) => conditions[k]).join("/");
            if (options.identityCache === false) {
                return model.find(conditions, options).run().then((items) => {
                    if (!items || items.length === 0) {
                        return reject(new Error_1.default("Not found", 'NOT_FOUND', { model: opts.table }));
                    }
                    resolve(items[0]);
                }).catch(reject);
            }
            Singleton_1.default.get(itemId, {
                identityCache: options.identityCache,
                saveCheck: opts.settings.get("instance.identityCacheSaveCheck")
            }, function (createCb) {
                model.find(conditions, options).run().then((items) => {
                    if (!items || items.length === 0) {
                        return createCb(new Error_1.default("Not found", 'NOT_FOUND', { model: opts.table }));
                    }
                    return createCb(null, items[0]);
                }).catch(createCb);
            }, function (err, item) {
                if (err)
                    reject(err);
                else
                    resolve(item || null);
            });
        });
    };
    model.find = function (...args) {
        assertNoCallback("find", args);
        const conditions = {};
        let options = {};
        let limit = undefined;
        let order = [];
        let merge = null;
        const optionKeys = new Set([
            "limit",
            "order",
            "offset",
            "merge",
            "exists",
            "identityCache",
            "autoFetch",
            "autoFetchLimit",
            "cascadeRemove",
            "__merge",
            "extra",
            "extra_info",
            "only",
            "fields"
        ]);
        const conditionSpecialKeys = new Set([
            "or",
            "and",
            "not",
            "not_or",
            "not_and",
            "exists",
            "like",
            "like_i"
        ]);
        const looksLikeOptions = (obj) => {
            const keys = Object.keys(obj);
            if (keys.length === 0)
                return false;
            for (const key of keys) {
                if (optionKeys.has(key)) {
                    if ((key === "order" || key === "limit" || key === "offset") && allProperties.hasOwnProperty(key)) {
                        continue;
                    }
                    return true;
                }
            }
            return false;
        };
        const looksLikeConditions = (obj) => {
            const keys = Object.keys(obj);
            if (keys.length === 0)
                return true;
            return keys.every((key) => allProperties.hasOwnProperty(key) || conditionSpecialKeys.has(key));
        };
        const appendOrder = (value) => {
            if (!value)
                return;
            if (typeof value === "string") {
                const standardized = Utilities.standardizeOrder(value);
                for (const entry of standardized) {
                    order.push(entry);
                }
                return;
            }
            if (!Array.isArray(value) || value.length === 0) {
                return;
            }
            const first = value[0];
            const second = value.length > 1 ? value[1] : undefined;
            const isDirectionToken = typeof second === "string" && second.length > 0 && ["A", "Z"].indexOf(second.toUpperCase()) >= 0;
            if (Array.isArray(first) && isDirectionToken && !Array.isArray(second)) {
                order.push([first, second.toUpperCase()]);
                return;
            }
            if (Array.isArray(first) && value.length === 1) {
                order.push([first, "A"]);
                return;
            }
            if (typeof first === "string") {
                const standardized = Utilities.standardizeOrder(value);
                for (const entry of standardized) {
                    order.push(entry);
                }
                return;
            }
            for (const item of value) {
                appendOrder(item);
            }
        };
        let hasConditionObject = false;
        let hasOptionsObject = false;
        for (let i = 0; i < args.length; i++) {
            switch (typeof args[i]) {
                case "number":
                    limit = args[i];
                    break;
                case "object":
                    if (Array.isArray(args[i])) {
                        const arrayArg = args[i];
                        const firstElement = arrayArg[0];
                        const isOrderArray = typeof firstElement === "string" || Array.isArray(firstElement);
                        if (arrayArg.length > 0 && isOrderArray) {
                            appendOrder(arrayArg);
                        }
                        else {
                            merge = {
                                from: arrayArg[0],
                                to: arrayArg[1],
                                select: arrayArg[2]
                            };
                        }
                    }
                    else {
                        const objectArg = args[i] || {};
                        const treatAsOptions = looksLikeOptions(objectArg) || (hasConditionObject && !looksLikeConditions(objectArg));
                        if (!hasConditionObject || (!treatAsOptions && !hasOptionsObject)) {
                            lodash_1.default.extend(conditions, objectArg);
                            hasConditionObject = true;
                        }
                        else {
                            lodash_1.default.extend(options, objectArg);
                            hasOptionsObject = true;
                        }
                    }
                    break;
                case "string":
                    if (args[i][0] === "-") {
                        order.push([args[i].substr(1), "Z"]);
                    }
                    else {
                        order.push([args[i], "A"]);
                    }
                    break;
            }
        }
        if (order.length === 0) {
            order = opts.order ? opts.order : [];
        }
        options = lodash_1.default.defaults(options, {
            identityCache: opts.settings.get("instance.identityCache"),
            autoFetch: opts.autoFetch,
            autoFetchLimit: opts.autoFetchLimit,
            cascadeRemove: opts.settings.get("instance.cascadeRemove")
        });
        if (options.order) {
            // Options order should replace any previously defined order
            order = [];
            appendOrder(options.order);
            delete options.order;
        }
        if (!merge && options.__merge) {
            merge = options.__merge;
        }
        if (options.__merge) {
            delete options.__merge;
        }
        if (limit !== undefined) {
            options.limit = limit;
        }
        if (typeof options.extra === "undefined") {
            options.extra = [];
        }
        else if (!Array.isArray(options.extra)) {
            options.extra = [options.extra];
        }
        if (typeof options.extra_info === "undefined") {
            options.extra_info = {};
        }
        if (merge) {
            options.extra.push(merge.from);
            options.merge = merge;
            if (typeof merge.select !== "undefined") {
                for (const k in merge.select) {
                    options.extra_info[k] = true;
                }
            }
        }
        let checkConditions = Utilities.checkConditions(conditions, one_associations);
        const chain = (0, ChainFind_1.default)(model, {
            only: model_fields,
            keys: Array.isArray(opts.keys) ? opts.keys : [opts.keys],
            table: opts.table,
            driver: opts.driver,
            conditions: checkConditions,
            associations: many_associations,
            limit: options.limit,
            order: order,
            merge: merge,
            offset: options.offset,
            properties: allProperties,
            keyProperties: keyProperties,
            newInstance: function (data, cb) {
                Utilities.renameDatastoreFieldsToPropertyNames(data, fieldToPropertyMap);
                const keys = Array.isArray(opts.keys) ? opts.keys : [opts.keys];
                let uid = opts.driver.uid + "/" + opts.table + (merge ? "+" + merge.from.table : "");
                for (let i = 0; i < keys.length; i++) {
                    uid += "/" + data[keys[i]];
                }
                // Extract merge table extra columns from the data
                let extra_info_with_values = options.extra_info;
                if (merge && merge.select && merge.selectMap && Array.isArray(merge.select) && merge.select.length > 0) {
                    extra_info_with_values = Object.assign({}, options.extra_info);
                    // merge.selectMap is a map of propertyName -> columnName
                    // merge.props contains the property definitions for type conversion
                    for (const propName in merge.selectMap) {
                        const columnName = merge.selectMap[propName];
                        if (columnName in data) {
                            let value = data[columnName];
                            // Convert the value using the property definition if available
                            if (merge.props && propName in merge.props && opts.driver.valueToProperty) {
                                const propDef = merge.props[propName];
                                value = opts.driver.valueToProperty(value, propDef);
                            }
                            extra_info_with_values[propName] = value;
                            // Remove the merge column from data so it doesn't become part of the instance
                            delete data[columnName];
                        }
                    }
                }
                Singleton_1.default.get(uid, {
                    identityCache: options.identityCache,
                    saveCheck: opts.settings.get("instance.identityCacheSaveCheck")
                }, function (createCb) {
                    return createInstance(data, {
                        uid: uid,
                        autoSave: opts.autoSave,
                        autoFetch: (options.autoFetchLimit === 0 ? false : (options.autoFetch || opts.autoFetch)),
                        autoFetchLimit: options.autoFetchLimit,
                        cascadeRemove: options.cascadeRemove,
                        extra: options.extra,
                        extra_info: extra_info_with_values
                    }, createCb);
                }, (err, instance) => {
                    if (cb) {
                        cb(err, instance);
                    }
                });
            }
        });
        return chain;
    };
    model.where = model.all = model.find;
    model.one = async function (...args) {
        assertNoCallback("one", args);
        let conditions = {};
        let options;
        if (args.length > 0 && typeof args[0] === "object" && !Array.isArray(args[0])) {
            conditions = args.shift() || {};
        }
        if (args.length > 0 && typeof args[0] === "object" && !Array.isArray(args[0])) {
            options = args.shift();
        }
        const chain = model.find(conditions, options);
        chain.limit(1);
        const results = await chain.run();
        return results && results.length ? results[0] : null;
    };
    model.count = function (...args) {
        assertNoCallback("count", args);
        let conditions = undefined;
        if (args.length > 0 && typeof args[0] === "object" && !Array.isArray(args[0])) {
            conditions = args.shift();
        }
        return new Promise((resolve, reject) => {
            let checkConditions = conditions;
            if (conditions) {
                checkConditions = Utilities.checkConditions(conditions, one_associations);
            }
            opts.driver.count(opts.table, checkConditions || {}, {}, function (err, data) {
                if (err || !data || data.length === 0) {
                    return reject(err || new Error("Count failed"));
                }
                return resolve(data[0].c);
            });
        });
    };
    model.aggregate = function (...args) {
        let conditions = {};
        let propertyList = [];
        for (let i = 0; i < args.length; i++) {
            if (typeof args[i] === "object") {
                if (Array.isArray(args[i])) {
                    propertyList = args[i];
                }
                else {
                    conditions = args[i];
                }
            }
        }
        if (conditions) {
            conditions = Utilities.checkConditions(conditions, one_associations);
        }
        return new (require("./AggregateFunctions"))({
            table: opts.table,
            driver_name: opts.driver_name,
            driver: opts.driver,
            conditions: conditions,
            propertyList: propertyList,
            properties: allProperties
        });
    };
    // Public async-only exists method
    model.exists = function (...ids) {
        assertNoCallback("exists", ids);
        return new Promise((resolve, reject) => {
            let conditions = {};
            let i;
            const keys = Array.isArray(opts.keys) ? opts.keys : [opts.keys];
            const params = ids.slice();
            if (params.length === 1 && typeof params[0] === "object") {
                if (Array.isArray(params[0])) {
                    for (i = 0; i < keys.length; i++) {
                        conditions[keys[i]] = params[0][i];
                    }
                }
                else {
                    conditions = params[0];
                }
            }
            else {
                for (i = 0; i < keys.length; i++) {
                    conditions[keys[i]] = params[i];
                }
            }
            if (conditions) {
                conditions = Utilities.checkConditions(conditions, one_associations);
            }
            opts.driver.count(opts.table, conditions, {}, function (err, data) {
                if (err || !data || data.length === 0) {
                    return reject(err);
                }
                return resolve(data[0].c > 0);
            });
        });
    };
    model.create = async function (...args) {
        const params = Array.from(args);
        assertNoCallback("create", params);
        let itemsParams = [];
        let options = {};
        let single = false;
        for (let i = 0; i < params.length; i++) {
            switch (typeof params[i]) {
                case "object":
                    if (!single && Array.isArray(params[i])) {
                        itemsParams = itemsParams.concat(params[i]);
                    }
                    else if (i === 0) {
                        single = true;
                        itemsParams.push(params[i]);
                    }
                    else {
                        options = params[i];
                    }
                    break;
            }
        }
        const items = [];
        for (let i = 0; i < itemsParams.length; i++) {
            const itemParams = itemsParams[i];
            const item = await new Promise((resolve, reject) => {
                createInstance(itemParams, {
                    is_new: true,
                    autoSave: false,
                    autoFetch: false
                }, (err, inst) => {
                    if (err)
                        reject(err);
                    else
                        resolve(inst);
                });
            });
            await item.save({}, options);
            items.push(item);
        }
        return single ? items[0] : items;
    };
    model.clear = async function () {
        assertNoCallback("clear", Array.from(arguments));
        await new Promise((resolve, reject) => {
            opts.driver.clear(opts.table, function (err) {
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    };
    model.prependValidation = function (key, validation) {
        const validations = opts.validations || {};
        if (validations.hasOwnProperty(key)) {
            validations[key].splice(0, 0, validation);
        }
        else {
            validations[key] = [validation];
        }
    };
    const currFields = {};
    model.addProperty = function (propIn, options) {
        let cType;
        const prop = Property_1.default.normalize({
            prop: propIn,
            name: (options && options.name) || propIn.name,
            customTypes: opts.db.customTypes,
            settings: opts.settings
        });
        let k = prop.name;
        const keys = Array.isArray(opts.keys) ? opts.keys : [opts.keys];
        if (keys.indexOf(k) !== -1) {
            prop.key = true;
        }
        else if (prop.key) {
            if (!opts.keys)
                opts.keys = [];
            if (Array.isArray(opts.keys)) {
                opts.keys.push(k);
            }
            else {
                opts.keys = [opts.keys, k];
            }
        }
        if (options && options.klass) {
            prop.klass = options.klass;
        }
        switch (prop.klass) {
            case 'primary':
                if (!opts.properties)
                    opts.properties = {};
                opts.properties[prop.name] = prop;
                break;
            case 'hasOne':
                association_properties.push(prop.name);
                break;
        }
        allProperties[prop.name] = prop;
        fieldToPropertyMap[prop.mapsTo] = prop;
        if (prop.required) {
            model.prependValidation(prop.name, Validators_1.default.required());
        }
        if (prop.key && prop.klass === 'primary') {
            keyProperties.push(prop);
        }
        if (prop.lazyload !== true && !currFields[prop.name]) {
            currFields[prop.name] = true;
            if ((cType = opts.db.customTypes[prop.type]) && cType.datastoreGet) {
                model_fields.push({
                    a: prop.mapsTo,
                    sql: cType.datastoreGet(prop, opts.db.driver.query)
                });
            }
            else {
                model_fields.push(prop.mapsTo);
            }
        }
        return prop;
    };
    // model.table and model.settings already set above (line 254-262)
    const validations = opts.validations || {};
    for (let k in validations) {
        if (!Array.isArray(validations[k])) {
            validations[k] = [validations[k]];
        }
    }
    const keys = Array.isArray(opts.keys) ? opts.keys : (opts.keys ? [opts.keys] : []);
    const properties = opts.properties || {};
    if (keys.length === 0 && !lodash_1.default.some(properties, { key: true })) {
        properties[opts.settings.get("properties.primary_key")] = {
            type: 'serial',
            key: true,
            required: false,
            klass: 'primary'
        };
    }
    for (const k in properties) {
        model.addProperty(properties[k], { name: k, klass: 'primary' });
    }
    if (keyProperties.length === 0) {
        throw new Error_1.default("Model defined without any keys", 'BAD_MODEL', { model: opts.table });
    }
    // Set model.properties to reference allProperties (not a copy)
    model.properties = allProperties;
    // Set model.id based on opts.keys
    Object.defineProperty(model, "id", {
        value: opts.keys,
        enumerable: false
    });
    Object.defineProperty(model, "uid", {
        value: opts.driver.uid + "/" + opts.table + "/" + (Array.isArray(opts.keys) ? opts.keys.join("/") : opts.keys),
        enumerable: false
    });
    for (const k in AvailableHooks) {
        model[AvailableHooks[k]] = createHookHelper(AvailableHooks[k]);
    }
    OneAssociation.prepare(model, one_associations);
    ManyAssociation.prepare(opts.db, model, many_associations);
    ExtendAssociation.prepare(opts.db, model, extend_associations);
    return model;
}
//# sourceMappingURL=Model.js.map