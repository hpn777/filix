/**
 * Utility functions for ORM
 */
import { Property } from './types/Core';
interface OneAssociation {
    name: string;
    model: Model;
    field: Record<string, any>;
}
interface Model {
    uid?: string;
    id: string[];
    properties: Record<string, Property>;
    settings: Record<string, any>;
}
/**
 * Order should be a String (with the property name assumed ascending)
 * or an Array or property String names.
 *
 * Examples:
 *
 * 1. 'property1' (ORDER BY property1 ASC)
 * 2. '-property1' (ORDER BY property1 DESC)
 * 3. [ 'property1' ] (ORDER BY property1 ASC)
 * 4. [ '-property1' ] (ORDER BY property1 DESC)
 * 5. [ 'property1', 'A' ] (ORDER BY property1 ASC)
 * 6. [ 'property1', 'Z' ] (ORDER BY property1 DESC)
 * 7. [ '-property1', 'A' ] (ORDER BY property1 ASC)
 * 8. [ 'property1', 'property2' ] (ORDER BY property1 ASC, property2 ASC)
 * 9. [ 'property1', '-property2' ] (ORDER BY property1 ASC, property2 DESC)
 * ...
 */
export declare function standardizeOrder(order: string | string[]): Array<[string, string]>;
/**
 * Operations
 * A) Build an index of associations, with their name as the key
 * B) Check for any conditions with a key in the association index
 * C) Ensure that our condition supports array values
 * D) Remove original condition (not DB compatible)
 * E) Convert our association fields into an array, indexes are the same as model.id
 * F) Iterate through values for the condition, only accept instances of the same type as the association
 */
export declare function checkConditions(conditions: Record<string, any>, one_associations: OneAssociation[]): Record<string, any>;
/**
 * Gets all the values within an object or array, optionally
 * using a keys array to get only specific values
 */
export declare function values(obj: Record<string, any> | any[], keys?: string[]): any[];
export declare function hasValues(obj: Record<string, any>, keys: string[]): boolean;
export declare function populateConditions(model: Model, fields: string[], source: Record<string, any>, target: Record<string, any>, overwrite?: boolean): void;
export declare function getConditions(model: Model, fields: string[], from: Record<string, any>): Record<string, any>;
interface WrapFieldObjectParams {
    field?: string | Record<string, any>;
    model: Model;
    altName: string;
    mapsTo?: string;
}
export declare function wrapFieldObject(params: WrapFieldObjectParams): Record<string, Property>;
export declare function formatField(model: Model, name: string, required: boolean, reversed?: boolean): Record<string, Property>;
interface ConvertPropOptions {
    required: boolean;
    makeKey?: boolean;
}
export declare function convertPropToJoinKeyProp(props: Record<string, Property>, opts: ConvertPropOptions): Record<string, Property>;
export declare function getRealPath(path_str: string, stack_index?: number): string;
export declare function transformPropertyNames(dataIn: Record<string, any>, properties: Record<string, Property>): Record<string, any>;
export declare function transformOrderPropertyNames(order: Array<[string, string] | [string[], string]>, properties: Record<string, Property>): Array<[string, string] | [string[], string]>;
export declare function renameDatastoreFieldsToPropertyNames(data: Record<string, any>, fieldToPropertyMap: Record<string, Property>): Record<string, any>;
export {};
//# sourceMappingURL=Utilities.d.ts.map