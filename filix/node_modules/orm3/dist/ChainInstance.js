"use strict";
/**
 * Chain Instance - Promise-based cursor over query results
 */
Object.defineProperty(exports, "__esModule", { value: true });
class ChainCursor {
    constructor(loader) {
        this.loader = loader;
        this.operations = [];
        this.cache = null;
    }
    enqueue(operation) {
        this.operations.push(operation);
        this.cache = null; // invalidate cache when new operation is added
        return this;
    }
    async loadProcessed() {
        if (!this.cache) {
            const baseItems = await this.loader();
            let result = baseItems.slice();
            for (const operation of this.operations) {
                result = await operation(result);
            }
            this.cache = result;
        }
        return this.cache;
    }
    filter(cb) {
        return this.enqueue(async (items) => {
            const filtered = [];
            for (let i = 0; i < items.length; i++) {
                if (await cb(items[i], i, items)) {
                    filtered.push(items[i]);
                }
            }
            return filtered;
        });
    }
    forEach(cb) {
        return this.enqueue(async (items) => {
            for (let i = 0; i < items.length; i++) {
                await cb(items[i], i, items);
            }
            return items;
        });
    }
    sort(sortFn) {
        return this.enqueue((items) => {
            return items.slice().sort(sortFn);
        });
    }
    async count() {
        const items = await this.loadProcessed();
        return items.length;
    }
    async get() {
        return this.loadProcessed();
    }
    async save() {
        const items = await this.loadProcessed();
        for (const item of items) {
            const candidate = item;
            if (typeof candidate?.save !== 'function') {
                throw new Error('ChainInstance.save() expects items with an async save() method.');
            }
            if (candidate.save.length > 0) {
                await new Promise((resolve, reject) => {
                    candidate.save((err) => {
                        if (err) {
                            return reject(err);
                        }
                        resolve();
                    });
                });
            }
            else {
                const result = candidate.save();
                if (result && typeof result.then === 'function') {
                    await result;
                }
            }
        }
    }
}
function ChainInstance(loader, initialIterator) {
    const cursor = new ChainCursor(loader);
    if (typeof initialIterator === 'function') {
        cursor.forEach(initialIterator);
    }
    return cursor;
}
exports.default = ChainInstance;
//# sourceMappingURL=ChainInstance.js.map