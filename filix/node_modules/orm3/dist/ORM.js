"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addAdapter = exports.Text = exports.ErrorCodes = exports.Settings = exports.Property = exports.settings = exports.singleton = exports.enforce = exports.validators = void 0;
exports.connect = connect;
exports.use = use;
exports.express = express;
const lodash_1 = __importDefault(require("lodash"));
const async_1 = __importDefault(require("async"));
const index_1 = __importDefault(require("./Validators/index"));
exports.enforce = index_1.default;
const events_1 = require("events");
const crypto_1 = require("crypto");
const url_1 = require("url");
const path = __importStar(require("path"));
const adapters = __importStar(require("./Adapters"));
const aliases_1 = __importDefault(require("./Drivers/aliases"));
const Error_1 = __importDefault(require("./Error"));
const Model_1 = __importDefault(require("./Model"));
const Settings_1 = __importDefault(require("./Settings"));
exports.Settings = Settings_1.default;
const Singleton_1 = __importDefault(require("./Singleton"));
exports.singleton = Singleton_1.default;
const Utilities = __importStar(require("./Utilities"));
const Validators_1 = __importDefault(require("./Validators/Validators"));
const propertyMapper_1 = require("./Drivers/DDL/meta/propertyMapper");
const SQLQuery_1 = __importDefault(require("./SQLQuery"));
const OPTS_TYPE_STRING = 'string';
const OPTS_TYPE_OBJ = 'object';
/**
 * @deprecated Use the `enforce` package directly instead
 */
exports.validators = Validators_1.default;
// specific to ORM, not in enforce for now
index_1.default.equalToProperty = Validators_1.default.equalToProperty;
index_1.default.unique = Validators_1.default.unique;
exports.settings = new Settings_1.default.Container(Settings_1.default.defaults());
var Property_1 = require("./Property");
Object.defineProperty(exports, "Property", { enumerable: true, get: function () { return __importDefault(Property_1).default; } });
exports.ErrorCodes = Error_1.default.codes;
const optsChecker = function (opts) {
    return [OPTS_TYPE_STRING, OPTS_TYPE_OBJ].some(function (element) { return typeof (opts) === element; });
};
const fileLoader = function (filePaths, cb) {
    const self = this;
    // Get the caller's directory using stack introspection
    let callerDir = process.cwd();
    try {
        const stack = new Error().stack || '';
        const stackLines = stack.split('\n');
        // Find the first stack line that's not in this module
        for (let i = 0; i < stackLines.length; i++) {
            const line = stackLines[i];
            // Look for file paths in the stack trace
            const match = line.match(/\(([^)]+\.js):/);
            if (match) {
                const filePath = match[1];
                // Skip ORM.js and load.js files
                if (!filePath.includes('/dist/ORM.js') &&
                    !filePath.includes('/src/ORM.ts')) {
                    callerDir = path.dirname(filePath);
                    break;
                }
            }
        }
    }
    catch (e) {
        // Ignore stack parsing errors
    }
    const iterator = function (filePath, cb) {
        try {
            // Resolve relative paths from the caller's directory
            let resolvedPath = filePath;
            if (!path.isAbsolute(filePath) && !filePath.startsWith('.')) {
                // It's a module name, try to use require.resolve
                try {
                    resolvedPath = require.resolve(filePath);
                }
                catch (e) {
                    // If require.resolve fails, just use the filePath as-is
                    resolvedPath = filePath;
                }
            }
            else if (!path.isAbsolute(filePath)) {
                // It's a relative path, resolve it from caller's directory
                resolvedPath = path.resolve(callerDir, filePath);
            }
            require(resolvedPath)(self, cb);
        }
        catch (err) {
            return cb(err);
        }
    };
    async_1.default.eachSeries(filePaths, iterator, cb);
};
async function connect(opts) {
    return new Promise((resolve, reject) => {
        if (arguments.length === 0 || !opts || !optsChecker(opts)) {
            reject(new Error_1.default("CONNECTION_URL_EMPTY", 'PARAM_MISMATCH'));
            return;
        }
        let parsedOpts;
        let originalUri;
        if (typeof opts === 'string') {
            if (opts.trim().length === 0) {
                reject(new Error_1.default("CONNECTION_URL_EMPTY", 'PARAM_MISMATCH'));
                return;
            }
            parsedOpts = (0, url_1.parse)(opts, true);
            originalUri = opts;
        }
        else if (typeof opts === 'object') {
            parsedOpts = lodash_1.default.cloneDeep(opts);
            if (typeof opts.href === 'string') {
                originalUri = opts.href;
            }
            else if (typeof opts.url === 'string') {
                originalUri = opts.url;
            }
        }
        if (typeof parsedOpts.href === 'string' && parsedOpts.href.length > 0) {
            originalUri = originalUri || parsedOpts.href;
        }
        parsedOpts.query = parsedOpts.query || {};
        for (const k in parsedOpts.query) {
            parsedOpts.query[k] = queryParamCast(parsedOpts.query[k]);
            parsedOpts[k] = parsedOpts.query[k];
        }
        if (!parsedOpts.database) {
            parsedOpts.database = (parsedOpts.pathname ? parsedOpts.pathname.substr(1) : "");
        }
        if (!parsedOpts.protocol) {
            reject(new Error_1.default("CONNECTION_URL_NO_PROTOCOL", 'PARAM_MISMATCH'));
            return;
        }
        if (parsedOpts.auth) {
            parsedOpts.user = parsedOpts.auth.split(":")[0];
            parsedOpts.password = parsedOpts.auth.split(":")[1];
        }
        let userProvided = Object.prototype.hasOwnProperty.call(parsedOpts, "user");
        let passwordProvided = Object.prototype.hasOwnProperty.call(parsedOpts, "password");
        if (!Object.prototype.hasOwnProperty.call(parsedOpts, "user")) {
            parsedOpts.user = "root";
        }
        if (!Object.prototype.hasOwnProperty.call(parsedOpts, "password")) {
            parsedOpts.password = "";
        }
        if (Object.prototype.hasOwnProperty.call(parsedOpts, "hostname")) {
            parsedOpts.host = parsedOpts.hostname;
        }
        let proto = parsedOpts.protocol.replace(/:$/, '');
        let db;
        if (aliases_1.default[proto]) {
            proto = aliases_1.default[proto];
        }
        if ((!parsedOpts.host || parsedOpts.host.length === 0) || (!parsedOpts.database || parsedOpts.database.length === 0)) {
            const envKey = `${proto.toUpperCase()}_DB_URL`;
            const envUrl = process.env[envKey];
            if (envUrl) {
                const envParsed = (0, url_1.parse)(envUrl, true);
                if (!parsedOpts.host || parsedOpts.host.length === 0) {
                    parsedOpts.host = envParsed.hostname || envParsed.host;
                }
                if (!parsedOpts.port && envParsed.port) {
                    parsedOpts.port = envParsed.port;
                }
                if ((!parsedOpts.database || parsedOpts.database.length === 0) && envParsed.pathname) {
                    parsedOpts.database = envParsed.pathname.replace(/^\//, '');
                }
                if ((!parsedOpts.user || parsedOpts.user === "root") && envParsed.auth) {
                    parsedOpts.user = envParsed.auth.split(":")[0];
                    userProvided = true;
                }
                if ((!parsedOpts.password || parsedOpts.password.length === 0) && envParsed.auth && envParsed.auth.indexOf(":") >= 0) {
                    parsedOpts.password = envParsed.auth.split(":")[1];
                    passwordProvided = true;
                }
                if (envParsed.query) {
                    parsedOpts.query = Object.assign({}, envParsed.query, parsedOpts.query || {});
                }
                if (typeof envUrl === 'string' && envUrl.length > 0) {
                    parsedOpts.href = envUrl;
                    originalUri = envUrl;
                }
            }
        }
        parsedOpts.__connectionUri = originalUri;
        parsedOpts.__authProvided = Boolean(parsedOpts.auth) || userProvided || passwordProvided;
        parsedOpts.__userProvided = userProvided;
        parsedOpts.__passwordProvided = passwordProvided;
        try {
            const Driver = adapters.get(proto);
            const settingsContainer = new Settings_1.default.Container(exports.settings.get('*'));
            const driver = new Driver(parsedOpts, null, {
                debug: 'debug' in parsedOpts.query ? parsedOpts.query.debug : settingsContainer.get("connection.debug"),
                pool: 'pool' in parsedOpts.query ? parsedOpts.query.pool : settingsContainer.get("connection.pool"),
                settings: settingsContainer
            });
            db = new ORM(proto, driver, settingsContainer);
            driver.connect(function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(db);
                }
            });
        }
        catch (ex) {
            if (ex.code === "MODULE_NOT_FOUND" || ex.message.indexOf('find module') > -1) {
                reject(new Error_1.default("Connection protocol not supported - have you installed the database driver for " + proto + "?", 'NO_SUPPORT'));
            }
            else {
                reject(ex);
            }
        }
    });
}
async function use(connection, proto, opts) {
    if (aliases_1.default[proto]) {
        proto = aliases_1.default[proto];
    }
    if (typeof opts === "function") {
        opts = {};
    }
    return new Promise((resolve, reject) => {
        try {
            const Driver = adapters.get(proto);
            const settingsContainer = new Settings_1.default.Container(exports.settings.get('*'));
            const driver = new Driver(null, connection, {
                debug: (opts && opts.query && opts.query.debug === 'true'),
                settings: settingsContainer
            });
            resolve(new ORM(proto, driver, settingsContainer));
        }
        catch (ex) {
            reject(ex);
        }
    });
}
exports.Text = SQLQuery_1.default.Text;
for (const k in SQLQuery_1.default.Comparators) {
    exports[SQLQuery_1.default.Comparators[k]] = SQLQuery_1.default[SQLQuery_1.default.Comparators[k]];
}
function express(...args) {
    return require("./Express").apply(null, args);
}
exports.addAdapter = adapters.add;
class ORM extends events_1.EventEmitter {
    constructor(driver_name, driver, settings) {
        super();
        this.validators = exports.validators;
        this.enforce = index_1.default;
        this.settings = settings;
        this.driver_name = driver_name;
        this.driver = driver;
        this.driver.uid = (0, crypto_1.randomUUID)();
        this.tools = {};
        this.models = {};
        this.plugins = [];
        this.customTypes = {};
        for (const k in SQLQuery_1.default.Comparators) {
            this.tools[SQLQuery_1.default.Comparators[k]] = SQLQuery_1.default[SQLQuery_1.default.Comparators[k]];
        }
        const onError = (err) => {
            if (this.settings.get("connection.reconnect")) {
                if (typeof this.driver.reconnect === "undefined") {
                    this.emit("error", new Error_1.default("Connection lost - driver does not support reconnection", 'CONNECTION_LOST'));
                    return;
                }
                this.driver.reconnect(() => {
                    this.driver.on("error", onError);
                });
                if (this.listeners("error").length === 0) {
                    return;
                }
            }
            this.emit("error", err);
        };
        driver.on("error", onError);
    }
    use(plugin_const, opts) {
        let plugin;
        if (typeof plugin_const === "string") {
            try {
                plugin_const = require(Utilities.getRealPath(plugin_const));
            }
            catch (e) {
                throw e;
            }
        }
        plugin = new plugin_const(this, opts || {});
        if (typeof plugin.define === "function") {
            for (const k in this.models) {
                plugin.define(this.models[k]);
            }
        }
        this.plugins.push(plugin);
        return this;
    }
    define(name, properties, opts) {
        let i;
        properties = properties || {};
        opts = opts || {};
        for (i = 0; i < this.plugins.length; i++) {
            if (typeof this.plugins[i].beforeDefine === "function") {
                this.plugins[i].beforeDefine(name, properties, opts);
            }
        }
        // Handle cache/identityCache option - create per-model settings if needed
        let modelSettings = this.settings;
        if (Object.prototype.hasOwnProperty.call(opts, "cache") || Object.prototype.hasOwnProperty.call(opts, "identityCache")) {
            // Create a new settings object that inherits from global settings
            const Settings = require('./Settings').default;
            modelSettings = new Settings.Container(this.settings.settings);
            const cacheValue = Object.prototype.hasOwnProperty.call(opts, "identityCache") ? opts.identityCache : opts.cache;
            modelSettings.set("instance.identityCache", cacheValue);
        }
        this.models[name] = (0, Model_1.default)({
            db: this,
            settings: modelSettings,
            driver_name: this.driver_name,
            driver: this.driver,
            table: opts.table || opts.collection || ((this.settings.get("model.namePrefix") || "") + name),
            properties: properties,
            extension: opts.extension || false,
            keys: opts.id,
            autoSave: Object.prototype.hasOwnProperty.call(opts, "autoSave") ? opts.autoSave : this.settings.get("instance.autoSave"),
            autoFetch: Object.prototype.hasOwnProperty.call(opts, "autoFetch") ? opts.autoFetch : this.settings.get("instance.autoFetch"),
            autoFetchLimit: opts.autoFetchLimit || this.settings.get("instance.autoFetchLimit"),
            cascadeRemove: Object.prototype.hasOwnProperty.call(opts, "cascadeRemove") ? opts.cascadeRemove : this.settings.get("instance.cascadeRemove"),
            hooks: opts.hooks || {},
            methods: opts.methods || {},
            validations: opts.validations || {}
        });
        for (i = 0; i < this.plugins.length; i++) {
            if (typeof this.plugins[i].define === "function") {
                this.plugins[i].define(this.models[name], this);
            }
        }
        return this.models[name];
    }
    defineType(name, opts) {
        this.customTypes[name] = opts;
        this.driver.customTypes[name] = opts;
        return this;
    }
    async ping(cb) {
        return new Promise((resolve, reject) => {
            this.driver.ping((err) => {
                if (typeof cb === "function") {
                    try {
                        cb(err || undefined);
                    }
                    catch (callbackErr) {
                        reject(callbackErr);
                        return;
                    }
                }
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    }
    async close(cb) {
        return new Promise((resolve, reject) => {
            this.driver.close((err) => {
                if (typeof cb === "function") {
                    try {
                        cb(err || undefined);
                    }
                    catch (callbackErr) {
                        reject(callbackErr);
                        return;
                    }
                }
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    }
    async load(...files) {
        const args = files.slice();
        let callback;
        if (args.length && typeof args[args.length - 1] === 'function') {
            callback = args.pop();
        }
        const collected = [];
        const collect = (entry) => {
            if (!entry)
                return;
            if (typeof entry === 'function')
                return;
            if (Array.isArray(entry)) {
                for (const item of entry) {
                    collect(item);
                }
            }
            else if (typeof entry === 'string') {
                collected.push(entry);
            }
        };
        args.forEach(arg => collect(arg));
        return new Promise((resolve, reject) => {
            fileLoader.call(this, collected, (err) => {
                if (err) {
                    if (callback) {
                        try {
                            callback(err);
                        }
                        catch (cbErr) {
                            return reject(cbErr);
                        }
                    }
                    reject(err);
                }
                else {
                    if (callback) {
                        try {
                            callback(null);
                        }
                        catch (cbErr) {
                            return reject(cbErr);
                        }
                    }
                    resolve();
                }
            });
        });
    }
    async sync() {
        const modelIds = Object.keys(this.models);
        for (const modelId of modelIds) {
            try {
                await this.models[modelId].sync();
            }
            catch (err) {
                if (err && typeof err === 'object') {
                    err.model = modelId;
                }
                throw err;
            }
        }
    }
    async drop() {
        const modelIds = Object.keys(this.models);
        for (const modelId of modelIds) {
            try {
                await this.models[modelId].drop();
            }
            catch (err) {
                if (err && typeof err === 'object') {
                    err.model = modelId;
                }
                throw err;
            }
        }
    }
    getMetadata(options) {
        if (typeof this.driver?.getMetadata !== 'function') {
            throw new Error_1.default("Metadata inspection is not supported by this driver", 'NO_SUPPORT');
        }
        return this.driver.getMetadata(options);
    }
    async defineFromSchema(tableName, options) {
        if (typeof tableName !== 'string' || tableName.trim().length === 0) {
            throw new Error_1.default("defineFromSchema() requires a non-empty table name", 'PARAM_MISMATCH');
        }
        const inspector = this.getMetadata(options);
        const columns = await inspector.getColumns(tableName);
        if (!Array.isArray(columns) || columns.length === 0) {
            throw new Error_1.default(`Unable to inspect columns for table '${tableName}'`, 'BAD_MODEL', { table: tableName });
        }
        const namingStrategy = options?.namingStrategy ?? 'preserve';
        const overrides = options?.propertyOverrides ?? {};
        const properties = {};
        const primaryKeys = new Set();
        const usedNames = new Set();
        for (const column of columns) {
            const columnName = column.getName();
            const propertyName = reservePropertyName(columnName, namingStrategy, usedNames);
            let property = (0, propertyMapper_1.mapColumnToProperty)(column);
            const columnOverride = overrides[columnName];
            const propertyOverride = overrides[propertyName];
            const overrideSources = [];
            if (columnOverride) {
                overrideSources.push(lodash_1.default.cloneDeep(columnOverride));
            }
            if (propertyOverride && propertyOverride !== columnOverride) {
                overrideSources.push(lodash_1.default.cloneDeep(propertyOverride));
            }
            if (overrideSources.length) {
                property = Object.assign(property, ...overrideSources);
            }
            if (column.isAutoIncrementing()) {
                property.serial = true;
                if (!property.type) {
                    property.type = 'serial';
                }
                if (!Object.prototype.hasOwnProperty.call(property, 'required')) {
                    property.required = false;
                }
            }
            const hasDefault = Object.prototype.hasOwnProperty.call(property, 'defaultValue');
            if (!Object.prototype.hasOwnProperty.call(property, 'required')) {
                property.required = !column.isNullable() && property.serial !== true && !hasDefault;
            }
            if (column.isUnique() && !Object.prototype.hasOwnProperty.call(property, 'unique')) {
                property.unique = true;
            }
            if (propertyName !== columnName && !Object.prototype.hasOwnProperty.call(property, 'mapsTo')) {
                property.mapsTo = columnName;
            }
            if (column.isPrimaryKey() && property.key !== true) {
                property.key = true;
            }
            const columnMeta = {
                name: column.getName(),
                dataType: column.getDataType(),
                notNull: !column.isNullable(),
                maxLength: column.getMaxLength() ?? null,
                primaryKey: column.isPrimaryKey(),
                defaultValue: column.getDefaultValue(),
                unique: column.isUnique(),
                autoIncrement: column.isAutoIncrementing(),
                referencedTableName: column.getReferencedTableName(),
                referencedColumnName: column.getReferencedColumnName(),
                onUpdate: column.getUpdateRule(),
                onDelete: column.getDeleteRule(),
            };
            Object.defineProperty(property, 'meta', {
                value: columnMeta,
                enumerable: false,
                configurable: true,
                writable: false,
            });
            properties[propertyName] = property;
            if (property.key === true) {
                primaryKeys.add(propertyName);
            }
        }
        let resolvedKeys = Array.from(primaryKeys);
        const optionId = options?.modelOptions?.id;
        if (resolvedKeys.length === 0 && optionId) {
            resolvedKeys = Array.isArray(optionId) ? optionId.slice() : [optionId];
        }
        if (resolvedKeys.length === 0) {
            throw new Error_1.default(`Unable to determine primary key(s) for table '${tableName}'. Provide options.modelOptions.id to override.`, 'BAD_MODEL', { table: tableName });
        }
        for (const keyName of resolvedKeys) {
            if (properties[keyName]) {
                properties[keyName].key = true;
            }
        }
        const baseModelOptions = options?.modelOptions ? lodash_1.default.cloneDeep(options.modelOptions) : {};
        const finalId = baseModelOptions.id ?? (resolvedKeys.length === 1 ? resolvedKeys[0] : resolvedKeys);
        baseModelOptions.table = baseModelOptions.table ?? tableName;
        baseModelOptions.id = finalId;
        const model = this.define(options?.name ?? tableName, properties, baseModelOptions);
        return model;
    }
    async defineAllFromSchema(options) {
        const inspector = this.getMetadata(options);
        try {
            const tables = await inspector.getTables();
            const includeViews = Boolean(options?.includeViews);
            const matchTable = createTableMatcher(options?.tables);
            const baseDefineOptions = options?.defineOptions ? lodash_1.default.cloneDeep(options.defineOptions) : undefined;
            const tableOptions = options?.tableOptions ?? {};
            const models = {};
            for (const table of tables) {
                if (!includeViews && table.getType() === 'VIEW') {
                    continue;
                }
                const tableName = table.getName();
                if (!matchTable(tableName, table)) {
                    continue;
                }
                const tableOverride = tableOptions[tableName];
                if (tableOverride?.skip) {
                    continue;
                }
                const { skip: _skip, ...restOverrides } = tableOverride ?? {};
                const mergedOptions = mergeDefineModelOptions(baseDefineOptions, restOverrides);
                if (!mergedOptions.schema && options?.schema) {
                    mergedOptions.schema = options.schema;
                }
                const modelName = mergedOptions.name
                    || buildModelName(tableName, options?.modelNamingStrategy, options?.modelNamePrefix);
                if (this.models[modelName]) {
                    models[modelName] = this.models[modelName];
                    continue;
                }
                mergedOptions.name = modelName;
                try {
                    const model = await this.defineFromSchema(tableName, mergedOptions);
                    models[modelName] = model;
                }
                catch (err) {
                    if (err && typeof err === 'object') {
                        err.table = tableName;
                        err.operation = 'defineAllFromSchema';
                    }
                    throw err;
                }
            }
            return models;
        }
        finally {
            await inspector.close();
        }
    }
    /**
     * Execute a set of chain runners sequentially, collecting each result set.
     *
     * The returned runner can be awaited directly or invoked with a callback
     * for legacy consumers. Results are typed according to the provided chain
     * runners, preserving strong typing across chained queries.
     */
    serial(...chains) {
        async function get(cb) {
            try {
                const results = [];
                for (const chain of chains) {
                    if (!chain || typeof chain.run !== 'function') {
                        throw new TypeError('serial() expects chain-like arguments exposing run()');
                    }
                    const instances = await chain.run();
                    results.push(instances || []);
                }
                if (typeof cb === 'function') {
                    cb(null, ...results);
                    return;
                }
                return results;
            }
            catch (err) {
                if (typeof cb === 'function') {
                    cb(err);
                    return;
                }
                throw err;
            }
        }
        return { get };
    }
}
function ORM_Error(err, cb) {
    const Emitter = new events_1.EventEmitter();
    Emitter.use = Emitter.define = Emitter.sync = Emitter.load = function () { };
    if (typeof cb === "function") {
        cb(err);
    }
    process.nextTick(function () {
        Emitter.emit("connect", err);
    });
    return Emitter;
}
function queryParamCast(val) {
    if (typeof val === 'string') {
        switch (val) {
            case '1':
            case 'true':
                return true;
            case '0':
            case 'false':
                return false;
        }
    }
    return val;
}
function createTableMatcher(option) {
    if (!option) {
        return () => true;
    }
    if (Array.isArray(option)) {
        const normalized = new Set(option.map((name) => name.toLowerCase()));
        return (tableName) => normalized.has(tableName.toLowerCase());
    }
    if (option instanceof RegExp) {
        return (tableName) => option.test(tableName);
    }
    if (typeof option === 'function') {
        return option;
    }
    return () => true;
}
function mergeDefineModelOptions(base, override) {
    const merged = lodash_1.default.merge({}, lodash_1.default.cloneDeep(base ?? {}), lodash_1.default.cloneDeep(override ?? {}));
    return merged;
}
function buildModelName(tableName, strategy = 'pascalCase', prefix = '') {
    let core;
    switch (strategy) {
        case 'preserve':
            core = tableName;
            break;
        case 'camelCase':
            core = lodash_1.default.camelCase(tableName);
            break;
        case 'pascalCase':
        default:
            core = lodash_1.default.upperFirst(lodash_1.default.camelCase(tableName));
            break;
    }
    if (prefix && !core.startsWith(prefix)) {
        return `${prefix}${core}`;
    }
    return core;
}
function reservePropertyName(columnName, strategy, usedNames) {
    const baseName = strategy === 'camelCase' ? (lodash_1.default.camelCase(columnName) || columnName) : columnName;
    let candidate = baseName;
    let attempt = 1;
    while (usedNames.has(candidate)) {
        candidate = `${baseName}_${attempt}`;
        attempt += 1;
    }
    usedNames.add(candidate);
    return candidate;
}
exports.default = ORM;
//# sourceMappingURL=ORM.js.map