"use strict";
/// <reference types="node" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = Driver;
const buffer_1 = require("buffer");
const url_1 = require("url");
const _ = __importStar(require("lodash"));
const mongodb = require("mongodb");
const resolveWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then((result) => cb(null, result)).catch((err) => cb(err));
        return;
    }
    return promise;
};
const resolveVoidWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then(() => cb(null)).catch((err) => cb(err));
        return;
    }
    return promise;
};
function Driver(config, connection, opts) {
    this.client = null;
    this.db = null;
    this.config = config || {};
    this.opts = opts;
    if (!this.config.timezone) {
        this.config.timezone = "local";
    }
    this.opts.settings.set("properties.primary_key", "_id");
    this.opts.settings.set("properties.association_key", function (name, field) {
        return name + "_" + field.replace(/^_+/, '');
    });
}
Driver.prototype.sync = function (opts, cb) {
    const promise = (async () => {
        const collection = await new Promise((resolve, reject) => {
            this.db.createCollection(opts.table, (err, created) => {
                if (err)
                    return reject(err);
                resolve(created);
            });
        });
        const indexes = [];
        for (let i = 0; i < opts.one_associations.length; i++) {
            if (opts.one_associations[i].extension)
                continue;
            if (opts.one_associations[i].reversed)
                continue;
            for (const k in opts.one_associations[i].field) {
                indexes.push(k);
            }
        }
        for (let i = 0; i < opts.many_associations.length; i++) {
            if (opts.many_associations[i].reversed)
                continue;
            indexes.push(opts.many_associations[i].name);
        }
        if (indexes.length === 0) {
            return;
        }
        await Promise.all(indexes.map((indexName) => new Promise((resolve, reject) => {
            collection.createIndex(indexName, (err) => {
                if (err)
                    return reject(err);
                resolve();
            });
        })));
    })();
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.drop = function (opts, cb) {
    const promise = new Promise((resolve, reject) => {
        this.db.collection(opts.table).drop((err) => {
            if (err && err.code !== 26) {
                return reject(err);
            }
            resolve();
        });
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.ping = function (cb) {
    const promise = new Promise((resolve) => {
        process.nextTick(() => resolve());
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.on = function (ev, cb) {
    // if (ev == "error") {
    //   this.db.on("error", cb);
    //   this.db.on("unhandledError", cb);
    // }
    return this;
};
Driver.prototype.connect = function (cb) {
    const uri = resolveConnectionString(this.config);
    const promise = (async () => {
        try {
            this.client = new mongodb.MongoClient(uri);
        }
        catch (err) {
            throw err;
        }
        await this.client.connect();
        try {
            const dbName = (typeof this.config.database === "string" && this.config.database.length > 0)
                ? this.config.database
                : undefined;
            this.db = dbName ? this.client.db(dbName) : this.client.db();
        }
        catch (err) {
            this.db = this.client.db();
        }
    })();
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.close = function (cb) {
    const promise = (async () => {
        if (this.client) {
            await this.client.close();
        }
        this.db = null;
        this.client = null;
    })();
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.find = function (fields, table, conditions, opts, cb) {
    const promise = (async () => {
        const collection = this.db.collection(table);
        convertToDB(conditions, this.config.timezone);
        const cursor = (fields ? collection.find(conditions, fields) : collection.find(conditions));
        if (opts.order) {
            const orders = [];
            for (let i = 0; i < opts.order.length; i++) {
                orders.push([opts.order[i][0], (opts.order[i][1] == 'Z' ? 'desc' : 'asc')]);
            }
            cursor.sort(orders);
        }
        if (opts.offset) {
            cursor.skip(opts.offset);
        }
        if (opts.limit) {
            cursor.limit(opts.limit);
        }
        const docs = await new Promise((resolve, reject) => {
            cursor.toArray((err, result) => {
                if (err)
                    return reject(err);
                resolve(result || []);
            });
        });
        const processed = await Promise.all(docs.map((doc) => {
            convertFromDB(doc, this.config.timezone);
            if (opts.extra && opts.extra[doc._id]) {
                doc = _.merge(doc, _.omit(opts.extra[doc._id], '_id'));
            }
            if (!opts.createInstance) {
                return Promise.resolve(doc);
            }
            return new Promise((resolve) => {
                const instance = opts.createInstance(doc, {
                    extra: opts.extra_props
                }, () => {
                    resolve(instance);
                });
            });
        }));
        return processed;
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.count = function (table, conditions, opts, cb) {
    const promise = (async () => {
        const collection = this.db.collection(table);
        convertToDB(conditions, this.config.timezone);
        const cursor = collection.find(conditions);
        if (opts.order) {
            const orders = [];
            for (let i = 0; i < opts.order.length; i++) {
                orders.push([opts.order[i][0], (opts.order[i][1] == 'Z' ? 'desc' : 'asc')]);
            }
            cursor.sort(orders);
        }
        if (opts.offset) {
            cursor.skip(opts.offset);
        }
        if (opts.limit) {
            cursor.limit(opts.limit);
        }
        const count = await new Promise((resolve, reject) => {
            cursor.count(true, (err, result) => {
                if (err)
                    return reject(err);
                resolve(result);
            });
        });
        return [{ c: count }];
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.insert = function (table, data, keyProperties, cb) {
    const promise = (async () => {
        convertToDB(data, this.config.timezone);
        const docs = await new Promise((resolve, reject) => {
            this.db.collection(table).insert(data, { w: 1 }, (err, inserted) => {
                if (err)
                    return reject(err);
                resolve(inserted || []);
            });
        });
        const ids = {};
        if (keyProperties && keyProperties.length && docs.length) {
            for (let i = 0; i < keyProperties.length; i++) {
                const prop = keyProperties[i];
                if (prop.mapsTo && prop.mapsTo in docs[0]) {
                    ids[prop.name] = docs[0][prop.mapsTo];
                }
            }
            convertFromDB(ids, this.config.timezone);
        }
        return ids;
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.hasMany = function (Model, association) {
    var db = this.db.collection(Model.table);
    var driver = this;
    return {
        has: function (Instance, Associations, conditions, cb) {
            return db.find({
                _id: new mongodb.ObjectID(Instance[Model.id])
            }, [association.name]).toArray(function (err, docs) {
                if (err)
                    return cb(err);
                if (!docs.length)
                    return cb(new Error("Not found"));
                if (!Array.isArray(docs[0][association.name]))
                    return cb(null, false);
                if (!docs[0][association.name].length)
                    return cb(null, false);
                var found;
                for (var i = 0; i < Associations.length; i++) {
                    found = false;
                    for (var j = 0; j < docs[0][association.name].length; j++) {
                        if (docs[0][association.name][j]._id == Associations[i][association.model.id]) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        return cb(null, false);
                    }
                }
                return cb(null, true);
            });
        },
        get: function (Instance, conditions, options, createInstance, cb) {
            return db.find({
                _id: new mongodb.ObjectID(Instance[Model.id])
            }, [association.name]).toArray(function (err, docs) {
                if (err)
                    return cb(err);
                if (!docs.length)
                    return cb(new Error("Not found"));
                if (!docs[0][association.name]) {
                    return cb(null, []);
                }
                var extra = {};
                conditions._id = { $in: [] };
                for (var i = 0; i < docs[0][association.name].length; i++) {
                    conditions._id.$in.push(new mongodb.ObjectID(docs[0][association.name][i]._id));
                    extra[docs[0][association.name][i]._id] = docs[0][association.name][i];
                }
                if (options.order) {
                    options.order[0] = options.order[0][1];
                }
                return association.model.find(conditions, options, function (e, docs) {
                    var i, len;
                    for (i = 0, len = docs.length; i < len; i++) {
                        if (extra.hasOwnProperty(docs[i][association.model.id])) {
                            docs[i].extra = extra[docs[i][association.model.id]];
                        }
                    }
                    cb(e, docs);
                });
            });
        },
        add: function (Instance, Association, data, cb) {
            var push = {};
            push[association.name] = { _id: Association[association.model.id] };
            for (var k in data) {
                push[association.name][k] = data[k];
            }
            return db.update({
                _id: new mongodb.ObjectID(Instance[Model.id])
            }, {
                $push: push
            }, {
                safe: true,
                upsert: true
            }, cb);
        },
        del: function (Instance, Associations, cb) {
            if (Associations.length === 0) {
                var unset = {};
                unset[association.name] = 1;
                return db.update({
                    _id: new mongodb.ObjectID(Instance[Model.id])
                }, {
                    $unset: unset
                }, {
                    safe: true,
                    upsert: true
                }, cb);
            }
            var pull = {};
            pull[association.name] = [];
            for (var i = 0; i < Associations.length; i++) {
                var props = { _id: Associations[i][association.model.id] };
                if (Associations[i].extra !== undefined) {
                    props = _.merge(props, _.pick(Associations[i].extra, _.keys(association.props)));
                }
                pull[association.name].push(props);
            }
            return db.update({
                _id: new mongodb.ObjectID(Instance[Model.id])
            }, {
                $pullAll: pull
            }, {
                safe: true,
                upsert: true
            }, cb);
        }
    };
};
Driver.prototype.update = function (table, changes, conditions, cb) {
    const promise = new Promise((resolve, reject) => {
        convertToDB(changes, this.config.timezone);
        convertToDB(conditions, this.config.timezone);
        this.db.collection(table).update(conditions, { $set: changes }, { safe: true, upsert: true }, (err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.remove = function (table, conditions, cb) {
    const promise = new Promise((resolve, reject) => {
        convertToDB(conditions, this.config.timezone);
        this.db.collection(table).remove(conditions, (err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.clear = function (table, cb) {
    const promise = new Promise((resolve, reject) => {
        this.db.collection(table).remove((err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
    return resolveVoidWithCallback(promise, cb);
};
function resolveConnectionString(config) {
    if (config && typeof config.href === "string" && config.href.length > 0) {
        return config.href;
    }
    if (config && typeof config.__connectionUri === "string" && config.__connectionUri.length > 0) {
        return config.__connectionUri;
    }
    const authProvided = Boolean(config && config.__authProvided);
    const userProvided = Boolean(config && config.__userProvided);
    const passwordProvided = Boolean(config && config.__passwordProvided);
    let authPart = "";
    if (authProvided) {
        const rawUser = userProvided && typeof config.user === "string" ? config.user : "";
        const rawPassword = passwordProvided && typeof config.password === "string" ? config.password : "";
        if (passwordProvided) {
            const encodedUser = encodeURIComponent(rawUser || "");
            const encodedPassword = encodeURIComponent(rawPassword);
            authPart = `${encodedUser}:${encodedPassword}@`;
        }
        else if (userProvided && rawUser) {
            authPart = `${encodeURIComponent(rawUser)}@`;
        }
    }
    const host = config && typeof config.host === "string" && config.host.length > 0
        ? config.host
        : "localhost";
    const port = config && (typeof config.port === "string" || typeof config.port === "number")
        ? `:${config.port}`
        : "";
    const database = config && typeof config.database === "string" && config.database.length > 0
        ? config.database
        : "";
    const databasePart = database ? `/${database}` : "";
    let query = "";
    if (config && config.query && typeof config.query === "object") {
        const params = new url_1.URLSearchParams();
        for (const [key, value] of Object.entries(config.query)) {
            if (value === undefined || value === null)
                continue;
            params.append(key, String(value));
        }
        const serialized = params.toString();
        if (serialized.length > 0) {
            query = `?${serialized}`;
        }
    }
    return `mongodb://${authPart}${host}${port}${databasePart}${query}`;
}
function convertToDB(obj, timeZone) {
    for (var k in obj) {
        if (['and', 'or', 'not'].indexOf(k) >= 0) {
            for (var j = 0; j < obj[k].length; j++) {
                convertToDB(obj[k][j], timeZone);
            }
            obj['$' + k] = obj[k];
            delete obj[k];
            continue;
        }
        if (Array.isArray(obj[k]) && k[0] != '$') {
            for (var i = 0; i < obj[k].length; i++) {
                obj[k][i] = convertToDBVal(k, obj[k][i], timeZone);
            }
            obj[k] = { $in: obj[k] };
            continue;
        }
        obj[k] = convertToDBVal(k, obj[k], timeZone);
    }
}
function convertFromDB(obj, timezone) {
    for (var k in obj) {
        if (obj[k] instanceof mongodb.ObjectID) {
            obj[k] = obj[k].toString();
            continue;
        }
        if (obj[k] instanceof mongodb.Binary) {
            obj[k] = buffer_1.Buffer.from ? buffer_1.Buffer.from(obj[k].value(), "binary") : new buffer_1.Buffer(obj[k].value(), "binary");
            continue;
        }
    }
}
function convertToDBVal(key, value, timezone) {
    if (value && typeof value.sql_comparator == "function") {
        var val = (key != "_id" ? value.val : new mongodb.ObjectID(value.val));
        var comp = value.sql_comparator();
        var condition = {};
        switch (comp) {
            case "gt":
            case "gte":
            case "lt":
            case "lte":
            case "ne":
                condition["$" + comp] = val;
                break;
            case "eq":
                condition = val;
                break;
            case "between":
                condition["$min"] = value.from;
                condition["$max"] = value.to;
                break;
            case "like":
                condition["$regex"] = value.expr.replace("%", ".*");
                break;
        }
        return condition;
    }
    if (buffer_1.Buffer.isBuffer(value)) {
        return new mongodb.Binary(value);
    }
    if (key == "_id" && typeof value == "string") {
        value = new mongodb.ObjectID(value);
    }
    return value;
}
// ==================== IDriver Implementation ====================
/**
 * Get driver settings
 */
Driver.prototype.getSettings = function () {
    return {
        dataTypes: {},
        escapeId: (name) => name,
        escapeVal: (val) => String(val)
    };
};
/**
 * Define a model in the database
 */
Driver.prototype.define = function (definition) {
    // TODO: Implement explicit model definition if needed
    // MongoDB is schemaless, so this is mostly a placeholder
};
/**
 * Get current database connection
 */
Driver.prototype.getConnection = function () {
    return this.db;
};
Object.defineProperty(Driver.prototype, "isSql", {
    value: false
});
//# sourceMappingURL=mongodb.js.map