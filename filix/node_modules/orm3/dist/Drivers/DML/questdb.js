"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = Driver;
const util = __importStar(require("util"));
const Debug_1 = __importDefault(require("../../Debug"));
const SQLQuery_1 = require("../../SQLQuery");
const shared = __importStar(require("./_shared"));
const postgres = require("./postgres");
const LARGE_LIMIT = '9223372036854775807';
const transformQueryForQuestdb = (sql) => {
    if (typeof sql !== 'string') {
        return sql;
    }
    const trimmed = sql.trimStart();
    if (!/^(select|with)/i.test(trimmed)) {
        return sql;
    }
    let transformed = sql.replace(/LIMIT\s+(\d+)\s+OFFSET\s+(\d+)/gi, (_match, limit, offset) => `LIMIT ${offset}, ${limit}`);
    if (!/LIMIT\s+\d+\s*,/i.test(transformed)) {
        transformed = transformed.replace(/OFFSET\s+(\d+)/gi, (_match, offset) => `LIMIT ${offset}, ${LARGE_LIMIT}`);
    }
    return transformed;
};
const resolveWithCallback = (promise, cb) => {
    if (typeof cb === 'function') {
        promise.then((result) => cb(null, result)).catch((error) => cb(error));
        return;
    }
    return promise;
};
const resolveVoidWithCallback = (promise, cb) => {
    if (typeof cb === 'function') {
        promise.then(() => cb(null)).catch((error) => cb(error));
        return;
    }
    return promise;
};
function Driver(config, connection, opts) {
    const questConfig = {
        port: 8812,
        ...config
    };
    if (questConfig.port) {
        const parsedPort = Number(questConfig.port);
        questConfig.port = Number.isFinite(parsedPort) ? parsedPort : 8812;
    }
    postgres.Driver.call(this, questConfig, connection, opts);
    // Ensure the query builder always uses the PostgreSQL dialect while reporting QuestDB as the driver dialect
    this.ddlDialect = 'questdb';
    this.queryDialect = 'postgresql';
    this.query = (0, SQLQuery_1.Query)({ dialect: this.queryDialect, timezone: this.config?.timezone || 'local' });
    this.dialect = 'questdb';
    // QuestDB does not yet support RETURNING for INSERT statements
    this.supportsReturning = false;
    const originalExecSimpleQuery = this.execSimpleQuery.bind(this);
    this.execSimpleQuery = function (query, cb) {
        const sql = typeof query === 'string' ? transformQueryForQuestdb(query) : query;
        return originalExecSimpleQuery(sql, cb);
    };
}
util.inherits(Driver, postgres.Driver);
Object.assign(Driver.prototype, {
    generateQuery: shared.generateQuery,
    execQuery: shared.execQuery,
    eagerQuery: shared.eagerQuery
});
Driver.prototype.insert = function (table, data, keyProperties, cb) {
    const promise = (async () => {
        const insertData = { ...data };
        if (Array.isArray(keyProperties) && keyProperties.length > 0) {
            for (const prop of keyProperties) {
                const columnName = prop.mapsTo;
                if (columnName && !Object.prototype.hasOwnProperty.call(insertData, columnName)) {
                    const escapedColumn = this.query.escapeId(columnName);
                    const escapedTable = this.query.escapeId(table);
                    const nextIdSql = `SELECT COALESCE(MAX(${escapedColumn}), 0) + 1 AS orm_next_id FROM ${escapedTable}`;
                    const rows = await this.execSimpleQuery(nextIdSql);
                    const row = Array.isArray(rows) && rows.length > 0 ? rows[0] : undefined;
                    const nextIdValue = row ? (row.orm_next_id ?? row.ORM_NEXT_ID ?? Object.values(row)[0]) : null;
                    const numericId = typeof nextIdValue === 'number' ? nextIdValue : Number(nextIdValue) || 1;
                    insertData[columnName] = numericId;
                }
            }
        }
        const insertSql = this.query.insert()
            .into(table)
            .set(insertData)
            .build();
        if (this.opts.debug) {
            Debug_1.default.sql('questdb', insertSql);
        }
        const ids = {};
        await this.execSimpleQuery(insertSql);
        if (Array.isArray(keyProperties)) {
            for (const prop of keyProperties) {
                if (!prop || !prop.mapsTo) {
                    ids[prop?.name ?? 'id'] = null;
                    continue;
                }
                if (Object.prototype.hasOwnProperty.call(insertData, prop.mapsTo)) {
                    ids[prop.name] = insertData[prop.mapsTo];
                }
                else if (Object.prototype.hasOwnProperty.call(data, prop.mapsTo)) {
                    ids[prop.name] = data[prop.mapsTo];
                }
                else {
                    ids[prop.name] = null;
                }
            }
        }
        return ids;
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.remove = function (table, conditions, cb) {
    const promise = (async () => {
        const hasConditions = conditions && typeof conditions === 'object' && Object.keys(conditions).length > 0;
        if (!hasConditions) {
            await this.clear(table);
            return [];
        }
        const baseTableNameRaw = typeof table === 'string' ? table.split('.').pop() || table : 'orm3_table';
        const baseTableName = baseTableNameRaw.replace(/"/g, '');
        const tempTable = `${baseTableName}__orm3_rm_${Date.now().toString(36)}_${Math.floor(Math.random() * 1e6).toString(36)}`;
        const escapedTempTable = this.query.escapeId(tempTable);
        const escapedOriginalTable = this.query.escapeId(table);
        const selectBuilder = this.query.select().from(table).where({ not: [conditions] });
        const selectSql = selectBuilder.build();
        const createSql = `CREATE TABLE ${escapedTempTable} AS (${selectSql})`;
        const dropSql = `DROP TABLE ${escapedOriginalTable}`;
        const renameSql = `RENAME TABLE ${escapedTempTable} TO ${escapedOriginalTable}`;
        try {
            await this.execSimpleQuery(`DROP TABLE IF EXISTS ${escapedTempTable}`);
            await this.execSimpleQuery(createSql);
            await this.execSimpleQuery(dropSql);
            await this.execSimpleQuery(renameSql);
        }
        catch (error) {
            try {
                await this.execSimpleQuery(`DROP TABLE IF EXISTS ${escapedTempTable}`);
            }
            catch (cleanupError) {
                if (this.opts && this.opts.debug) {
                    Debug_1.default.sql('questdb', `cleanup failed for ${escapedTempTable}: ${cleanupError}`);
                }
            }
            throw error;
        }
        return [];
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.ping = function (cb) {
    const promise = (async () => {
        await this.execSimpleQuery('SELECT 1');
    })();
    return resolveVoidWithCallback(promise, cb);
};
exports.default = Driver;
//# sourceMappingURL=questdb.js.map