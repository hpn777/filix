"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = Driver;
const _ = __importStar(require("lodash"));
const sqlite3 = require("sqlite3");
const SQLQuery_1 = require("../../SQLQuery");
const shared = __importStar(require("./_shared"));
const DDL = __importStar(require("../DDL/SQL"));
const resolveWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then((result) => cb(null, result)).catch((err) => cb(err));
        return;
    }
    return promise;
};
const resolveVoidWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then(() => cb(null)).catch((err) => cb(err));
        return;
    }
    return promise;
};
function Driver(config, connection, opts) {
    this.dialect = 'sqlite';
    this.config = config || {};
    this.opts = opts || {};
    if (!this.config.timezone) {
        this.config.timezone = "local";
    }
    this.query = (0, SQLQuery_1.Query)({ dialect: this.dialect, timezone: this.config.timezone });
    this.customTypes = {};
    if (connection) {
        this.db = connection;
    }
    else {
        // on Windows, paths have a drive letter which is parsed by
        // url.parse() as the hostname. If host is defined, assume
        // it's the drive letter and add ":"
        if (process.platform == "win32" && config.host && config.host.match(/^[a-z]$/i)) {
            this.db = new sqlite3.Database(decodeURIComponent((config.host ? config.host + ":" : "") + (config.pathname || "")) || ':memory:');
        }
        else {
            this.db = new sqlite3.Database(decodeURIComponent((config.host ? config.host : "") + (config.pathname || "")) || ':memory:');
        }
    }
    this.aggregate_functions = ["ABS", "ROUND",
        "AVG", "MIN", "MAX",
        "RANDOM",
        "SUM", "COUNT",
        "DISTINCT"];
}
_.extend(Driver.prototype, shared, DDL);
Driver.prototype.ping = function (cb) {
    const promise = new Promise((resolve) => {
        process.nextTick(() => resolve());
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.on = function (ev, cb) {
    if (ev == "error") {
        this.db.on("error", cb);
    }
    return this;
};
Driver.prototype.connect = function (cb) {
    const promise = new Promise((resolve) => {
        process.nextTick(() => resolve());
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.close = function (cb) {
    const promise = new Promise((resolve, reject) => {
        this.db.close((err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.getQuery = function () {
    return this.query;
};
Driver.prototype.execSimpleQuery = function (query, cb) {
    const promise = new Promise((resolve, reject) => {
        if (this.opts.debug) {
            require("../../Debug").sql('sqlite', query);
        }
        this.db.all(query, (err, rows) => {
            if (err)
                return reject(err);
            resolve(rows);
        });
    });
    return resolveWithCallback(promise, cb);
};
Driver.prototype.find = function (fields, table, conditions, opts, cb) {
    var q = this.query.select()
        .from(table).select(fields);
    if (opts.offset) {
        q.offset(opts.offset);
    }
    if (typeof opts.limit == "number") {
        q.limit(opts.limit);
    }
    else if (opts.offset) {
        // OFFSET cannot be used without LIMIT so we use the biggest INTEGER number possible
        q.limit('9223372036854775807');
    }
    if (opts.order) {
        for (var i = 0; i < opts.order.length; i++) {
            q.order(opts.order[i][0], opts.order[i][1]);
        }
    }
    if (opts.merge) {
        q.from(opts.merge.from.table, opts.merge.from.field, opts.merge.to.field).select(opts.merge.select);
        if (opts.merge.where && Object.keys(opts.merge.where[1]).length) {
            q = q.where(opts.merge.where[0], opts.merge.where[1], opts.merge.table || null, conditions);
        }
        else {
            q = q.where(opts.merge.table || null, conditions);
        }
    }
    else {
        q = q.where(conditions);
    }
    if (opts.exists) {
        for (var k in opts.exists) {
            q.whereExists(opts.exists[k].table, table, opts.exists[k].link, opts.exists[k].conditions);
        }
    }
    q = q.build();
    if (this.opts.debug) {
        require("../../Debug").sql('sqlite', q);
    }
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.count = function (table, conditions, opts, cb) {
    var q = this.query.select()
        .from(table)
        .count(null, 'c');
    if (opts.merge) {
        q.from(opts.merge.from.table, opts.merge.from.field, opts.merge.to.field);
        if (opts.merge.where && Object.keys(opts.merge.where[1]).length) {
            q = q.where(opts.merge.where[0], opts.merge.where[1], conditions);
        }
        else {
            q = q.where(conditions);
        }
    }
    else {
        q = q.where(conditions);
    }
    if (opts.exists) {
        for (var k in opts.exists) {
            q.whereExists(opts.exists[k].table, table, opts.exists[k].link, opts.exists[k].conditions);
        }
    }
    q = q.build();
    if (this.opts.debug) {
        require("../../Debug").sql('sqlite', q);
    }
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.insert = function (table, data, keyProperties, cb) {
    var q = this.query.insert()
        .into(table)
        .set(data)
        .build();
    if (this.opts.debug) {
        require("../../Debug").sql('sqlite', q);
    }
    const promise = (async () => {
        await this.execSimpleQuery(q);
        if (!keyProperties || keyProperties.length === 0) {
            return undefined;
        }
        if (keyProperties.length === 1 && keyProperties[0].type === 'serial') {
            const row = await new Promise((resolve, reject) => {
                this.db.get("SELECT last_insert_rowid() AS last_row_id", (err, fetchedRow) => {
                    if (err)
                        return reject(err);
                    resolve(fetchedRow);
                });
            });
            const ids = {};
            ids[keyProperties[0].name] = row?.last_row_id;
            return ids;
        }
        const ids = {};
        for (let i = 0; i < keyProperties.length; i++) {
            const prop = keyProperties[i];
            ids[prop.name] = data[prop.mapsTo] !== undefined ? data[prop.mapsTo] : null;
        }
        return ids;
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.update = function (table, changes, conditions, cb) {
    var q = this.query.update()
        .into(table)
        .set(changes)
        .where(conditions)
        .build();
    if (this.opts.debug) {
        require("../../Debug").sql('sqlite', q);
    }
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.remove = function (table, conditions, cb) {
    var q = this.query.remove()
        .from(table)
        .where(conditions)
        .build();
    if (this.opts.debug) {
        require("../../Debug").sql('sqlite', q);
    }
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.clear = function (table, cb) {
    const promise = (async () => {
        await this.execQuery("DELETE FROM ??", [table]);
        const data = await this.execQuery("SELECT count(*) FROM ?? WHERE type=? AND name=?;", ['sqlite_master', 'table', 'sqlite_sequence']);
        const hasSequence = data[0] && (data[0]['count(*)'] === 1 || data[0]['COUNT(*)'] === 1 || data[0]['count'] === 1);
        if (hasSequence) {
            await this.execQuery("DELETE FROM ?? WHERE NAME = ?", ['sqlite_sequence', table]);
        }
    })();
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.valueToProperty = function (value, property) {
    var v, customType;
    switch (property.type) {
        case "boolean":
            value = !!value;
            break;
        case "object":
            if (typeof value == "object" && !Buffer.isBuffer(value)) {
                break;
            }
            try {
                value = JSON.parse(value);
            }
            catch (e) {
                value = null;
            }
            break;
        case "number":
            if (typeof value == 'string') {
                switch (value.trim()) {
                    case 'Infinity':
                    case '-Infinity':
                    case 'NaN':
                        value = Number(value);
                        break;
                    default:
                        v = parseFloat(value);
                        if (Number.isFinite(v)) {
                            value = v;
                        }
                }
            }
            break;
        case "integer":
            if (typeof value == 'string') {
                v = parseInt(value);
                if (Number.isFinite(v)) {
                    value = v;
                }
            }
            break;
        case "date":
            if (typeof value == 'string') {
                const hasTrailingZ = value.indexOf('Z', value.length - 1) !== -1;
                value = new Date(hasTrailingZ ? value : value + 'Z');
                if (this.config.timezone && this.config.timezone != 'local') {
                    var tz = convertTimezone(this.config.timezone);
                    if (tz !== false) {
                        // shift UTC to timezone
                        value.setTime(value.getTime() - (tz * 60000));
                    }
                }
                else if (hasTrailingZ) {
                    // align to current local timezone offset
                    const localOffsetMinutes = (new Date()).getTimezoneOffset();
                    value.setTime(value.getTime() + (localOffsetMinutes * 60000));
                }
            }
            break;
        default:
            customType = this.customTypes[property.type];
            if (customType && 'valueToProperty' in customType) {
                value = customType.valueToProperty(value);
            }
    }
    return value;
};
Driver.prototype.propertyToValue = function (value, property) {
    var customType;
    switch (property.type) {
        case "boolean":
            value = (value) ? 1 : 0;
            break;
        case "object":
            if (value !== null) {
                value = JSON.stringify(value);
            }
            break;
        case "date":
            if (this.config.query && this.config.query.strdates) {
                if (value instanceof Date) {
                    var year = value.getUTCFullYear();
                    var month = value.getUTCMonth() + 1;
                    if (month < 10) {
                        month = '0' + month;
                    }
                    var date = value.getUTCDate();
                    if (date < 10) {
                        date = '0' + date;
                    }
                    var strdate = year + '-' + month + '-' + date;
                    if (property.time === false) {
                        value = strdate;
                        break;
                    }
                    var hours = value.getUTCHours();
                    if (hours < 10) {
                        hours = '0' + hours;
                    }
                    var minutes = value.getUTCMinutes();
                    if (minutes < 10) {
                        minutes = '0' + minutes;
                    }
                    var seconds = value.getUTCSeconds();
                    if (seconds < 10) {
                        seconds = '0' + seconds;
                    }
                    var millis = value.getUTCMilliseconds();
                    if (millis < 10) {
                        millis = '0' + millis;
                    }
                    if (millis < 100) {
                        millis = '0' + millis;
                    }
                    strdate += ' ' + hours + ':' + minutes + ':' + seconds + '.' + millis + '000';
                    value = strdate;
                }
            }
            break;
        default:
            customType = this.customTypes[property.type];
            if (customType && 'propertyToValue' in customType) {
                value = customType.propertyToValue(value);
            }
    }
    return value;
};
// ==================== IDriver Implementation ====================
/**
 * Get driver settings
 */
Driver.prototype.getSettings = function () {
    return {
        dataTypes: this.query.dataTypes || {},
        escapeId: (name) => this.query.escapeId(name),
        escapeVal: (val) => this.query.escape(val)
    };
};
/**
 * Define a model in the database
 */
Driver.prototype.define = function (definition) {
    // TODO: Implement explicit model definition if needed
    // Currently handled through sync() in DDL
};
/**
 * Get current database connection
 */
Driver.prototype.getConnection = function () {
    return this.db;
};
Object.defineProperty(Driver.prototype, "isSql", {
    value: true
});
function convertTimezone(tz) {
    if (tz == "Z")
        return 0;
    var m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
    if (m) {
        return (m[1] == '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;
    }
    return false;
}
//# sourceMappingURL=sqlite.js.map