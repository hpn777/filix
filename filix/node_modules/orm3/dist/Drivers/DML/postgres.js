"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = Driver;
const lodash_1 = __importDefault(require("lodash"));
const buffer_1 = require("buffer");
const pg = require('pg');
const SQLQuery_1 = require("../../SQLQuery");
const shared = __importStar(require("./_shared"));
const DDL = __importStar(require("../DDL/SQL"));
const resolveWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then((result) => cb(null, result)).catch((err) => cb(err));
        return;
    }
    return promise;
};
const resolveVoidWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then(() => cb(null)).catch((err) => cb(err));
        return;
    }
    return promise;
};
const isConnectionClosedError = (err) => {
    if (!err || typeof err !== "object") {
        return false;
    }
    const message = typeof err.message === "string" ? err.message.toLowerCase() : "";
    return message.includes("client was closed") || message.includes("client has already been closed") || message.includes("not queryable");
};
const objectValuesToBuffer = (value) => {
    if (Array.isArray(value)) {
        return buffer_1.Buffer.from(value);
    }
    if (value && typeof value === "object") {
        const ordered = Object.keys(value)
            .sort((a, b) => Number(a) - Number(b))
            .map((key) => value[key]);
        return buffer_1.Buffer.from(ordered);
    }
    if (typeof value === "string") {
        return buffer_1.Buffer.from(value, "binary");
    }
    return buffer_1.Buffer.alloc(0);
};
const parseJsonLikeToBuffer = (value) => {
    try {
        const parsed = JSON.parse(value);
        if (Array.isArray(parsed)) {
            return buffer_1.Buffer.from(parsed);
        }
        if (parsed && typeof parsed === "object") {
            return objectValuesToBuffer(parsed);
        }
    }
    catch (err) {
        return null;
    }
    return null;
};
const fromMaybeJsonBuffer = (buf) => {
    if (!buffer_1.Buffer.isBuffer(buf) || buf.length === 0) {
        return buf;
    }
    const firstByte = buf[0];
    if (firstByte === 0x7b || firstByte === 0x5b) { // '{' or '['
        const parsed = parseJsonLikeToBuffer(buf.toString());
        if (parsed) {
            return parsed;
        }
    }
    return buf;
};
const switchableFunctions = {
    pool: {
        connect: function (cb) {
            const promise = (async () => {
                const client = await this.db.connect();
                try {
                    this.connected = true;
                }
                finally {
                    if (client && typeof client.release === "function") {
                        client.release();
                    }
                }
            })();
            return resolveVoidWithCallback(promise, cb);
        },
        execSimpleQuery: function (query, cb) {
            const promise = (async () => {
                if (this.opts.debug) {
                    require("../../Debug").sql('postgres', query);
                }
                const client = await this.db.connect();
                try {
                    const result = await client.query(query);
                    return result.rows;
                }
                finally {
                    if (client && typeof client.release === "function") {
                        client.release();
                    }
                }
            })();
            return resolveWithCallback(promise, cb);
        }
    },
    client: {
        connect: function (cb) {
            const promise = (async () => {
                await this.db.connect();
                this.connected = true;
            })();
            return resolveVoidWithCallback(promise, cb);
        },
        execSimpleQuery: function (query, cb) {
            const promise = (async () => {
                if (this.opts.debug) {
                    require("../../Debug").sql('postgres', query);
                }
                const runQuery = async () => {
                    const result = await this.db.query(query);
                    return result.rows;
                };
                if (!this.connected) {
                    await this.connect();
                }
                try {
                    return await runQuery();
                }
                catch (err) {
                    if (isConnectionClosedError(err)) {
                        this.connected = false;
                        await this.connect();
                        return await runQuery();
                    }
                    throw err;
                }
            })();
            return resolveWithCallback(promise, cb);
        }
    }
};
function Driver(config, connection, opts) {
    const functions = switchableFunctions.client;
    this.dialect = 'postgresql';
    this.config = config || {};
    this.opts = opts || {};
    if (!this.config.timezone) {
        this.config.timezone = "local";
    }
    this.query = (0, SQLQuery_1.Query)({ dialect: this.dialect, timezone: this.config.timezone });
    this.customTypes = {};
    this.connected = false;
    if (connection) {
        this.db = connection;
        this.connected = true;
    }
    else {
        if (this.config.query && this.config.query.ssl) {
            config.ssl = true;
            this.config = lodash_1.default.extend(this.config, config);
        }
        pg.types.setTypeParser(20, Number);
        if (opts && opts.pool) {
            lodash_1.default.extend(this.constructor.prototype, switchableFunctions.pool);
            this.db = new pg.Pool(this.config);
        }
        else {
            lodash_1.default.extend(this.constructor.prototype, switchableFunctions.client);
            this.db = new pg.Client(this.config);
        }
    }
    this.aggregate_functions = [
        "ABS", "CEIL", "FLOOR", "ROUND",
        "AVG", "MIN", "MAX",
        "LOG", "EXP", "POWER",
        "ACOS", "ASIN", "ATAN", "COS", "SIN", "TAN",
        "RANDOM", "RADIANS", "DEGREES",
        "SUM", "COUNT",
        "DISTINCT"
    ];
}
lodash_1.default.extend(Driver.prototype, shared, DDL);
Driver.prototype.on = function (ev, cb) {
    if (ev === "error") {
        this.db.on("error", cb);
    }
    return this;
};
Driver.prototype.ping = function (cb) {
    const promise = (async () => {
        await this.execSimpleQuery("SELECT * FROM pg_stat_activity LIMIT 1");
    })();
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.close = function (cb) {
    const promise = (async () => {
        try {
            if (this.db && typeof this.db.end === "function") {
                await this.db.end();
            }
        }
        finally {
            if (this.opts && this.opts.pool) {
                this.db = new pg.Pool(this.config);
            }
            else {
                this.db = new pg.Client(this.config);
            }
            this.connected = false;
        }
    })();
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.getQuery = function () {
    return this.query;
};
Driver.prototype.find = function (fields, table, conditions, opts, cb) {
    let q = this.query.select().from(table).select(fields);
    if (opts.offset) {
        q.offset(opts.offset);
    }
    if (typeof opts.limit === "number") {
        q.limit(opts.limit);
    }
    if (opts.order) {
        for (let i = 0; i < opts.order.length; i++) {
            q.order(opts.order[i][0], opts.order[i][1]);
        }
    }
    if (opts.merge) {
        q.from(opts.merge.from.table, opts.merge.from.field, opts.merge.to.field).select(opts.merge.select);
        if (opts.merge.where && Object.keys(opts.merge.where[1]).length) {
            q = q.where(opts.merge.where[0], opts.merge.where[1], opts.merge.table || null, conditions);
        }
        else {
            q = q.where(opts.merge.table || null, conditions);
        }
    }
    else {
        q = q.where(conditions);
    }
    if (opts.exists) {
        for (const k in opts.exists) {
            q.whereExists(opts.exists[k].table, table, opts.exists[k].link, opts.exists[k].conditions);
        }
    }
    q = q.build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.count = function (table, conditions, opts, cb) {
    let q = this.query.select().from(table).count(null, 'c');
    if (opts.merge) {
        q.from(opts.merge.from.table, opts.merge.from.field, opts.merge.to.field);
        if (opts.merge.where && Object.keys(opts.merge.where[1]).length) {
            q = q.where(opts.merge.where[0], opts.merge.where[1], conditions);
        }
        else {
            q = q.where(conditions);
        }
    }
    else {
        q = q.where(conditions);
    }
    if (opts.exists) {
        for (const k in opts.exists) {
            q.whereExists(opts.exists[k].table, table, opts.exists[k].link, opts.exists[k].conditions);
        }
    }
    q = q.build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.insert = function (table, data, keyProperties, cb) {
    const q = this.query.insert().into(table).set(data).build();
    const promise = (async () => {
        const results = await this.execSimpleQuery(q + " RETURNING *");
        const ids = {};
        if (keyProperties) {
            for (let i = 0; i < keyProperties.length; i++) {
                const prop = keyProperties[i];
                ids[prop.name] = results[0][prop.mapsTo] !== undefined ? results[0][prop.mapsTo] : null;
            }
        }
        return ids;
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.update = function (table, changes, conditions, cb) {
    const q = this.query.update().into(table).set(changes).where(conditions).build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.remove = function (table, conditions, cb) {
    const q = this.query.remove().from(table).where(conditions).build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.clear = function (table, cb) {
    const q = "TRUNCATE TABLE " + this.query.escapeId(table);
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.valueToProperty = function (value, property) {
    let customType;
    let v;
    switch (property.type) {
        case "object":
            if (typeof value === "object" && !buffer_1.Buffer.isBuffer(value)) {
                break;
            }
            try {
                value = JSON.parse(value);
            }
            catch (e) {
                value = null;
            }
            break;
        case "point":
            if (typeof value === "string") {
                const m = value.match(/\((\-?[\d\.]+)[\s,]+(\-?[\d\.]+)\)/);
                if (m) {
                    value = { x: parseFloat(m[1]), y: parseFloat(m[2]) };
                }
            }
            break;
        case "date":
            if (lodash_1.default.isDate(value) && this.config.timezone && this.config.timezone !== 'local') {
                const tz = convertTimezone(this.config.timezone);
                value.setTime(value.getTime() - (value.getTimezoneOffset() * 60000));
                if (tz !== false) {
                    value.setTime(value.getTime() - (tz * 60000));
                }
            }
            break;
        case "binary":
            if (value === null || typeof value === "undefined") {
                break;
            }
            if (buffer_1.Buffer.isBuffer(value)) {
                value = fromMaybeJsonBuffer(value);
                break;
            }
            if (typeof value === "string") {
                if (value.startsWith("\\x") || value.startsWith("0x")) {
                    const hex = value.replace(/^\\x|^0x/i, "");
                    value = buffer_1.Buffer.from(hex, "hex");
                    break;
                }
                const parsedBuffer = parseJsonLikeToBuffer(value);
                if (parsedBuffer) {
                    value = parsedBuffer;
                    break;
                }
                value = buffer_1.Buffer.from(value, "binary");
                break;
            }
            if (Array.isArray(value) || (value && typeof value === "object")) {
                value = objectValuesToBuffer(value);
            }
            break;
        case "number":
            if (typeof value === 'string') {
                switch (value.trim()) {
                    case 'Infinity':
                    case '-Infinity':
                    case 'NaN':
                        value = Number(value);
                        break;
                    default:
                        v = parseFloat(value);
                        if (Number.isFinite(v)) {
                            value = v;
                        }
                }
            }
            break;
        case "integer":
            if (typeof value === 'string') {
                v = parseInt(value);
                if (Number.isFinite(v)) {
                    value = v;
                }
            }
            break;
        default:
            customType = this.customTypes[property.type];
            if (customType && 'valueToProperty' in customType) {
                value = customType.valueToProperty(value);
            }
    }
    return value;
};
Driver.prototype.propertyToValue = function (value, property) {
    let customType;
    switch (property.type) {
        case "object":
            if (value !== null && !buffer_1.Buffer.isBuffer(value)) {
                value = buffer_1.Buffer.from ? buffer_1.Buffer.from(JSON.stringify(value)) : new buffer_1.Buffer(JSON.stringify(value));
            }
            break;
        case "date":
            if (lodash_1.default.isDate(value) && this.config.timezone && this.config.timezone !== 'local') {
                const tz = convertTimezone(this.config.timezone);
                value.setTime(value.getTime() + (value.getTimezoneOffset() * 60000));
                if (tz !== false) {
                    value.setTime(value.getTime() + (tz * 60000));
                }
            }
            break;
        case "point":
            return function () {
                return "POINT(" + value.x + ', ' + value.y + ")";
            };
        default:
            customType = this.customTypes[property.type];
            if (customType && 'propertyToValue' in customType) {
                value = customType.propertyToValue(value);
            }
    }
    return value;
};
// ==================== IDriver Implementation ====================
/**
 * Get driver settings
 */
Driver.prototype.getSettings = function () {
    return {
        dataTypes: this.query.dataTypes || {},
        escapeId: (name) => this.query.escapeId(name),
        escapeVal: (val) => this.query.escape(val)
    };
};
/**
 * Define a model in the database
 */
Driver.prototype.define = function (definition) {
    // TODO: Implement explicit model definition if needed
    // Currently handled through sync() in DDL
};
/**
 * Get current database connection
 */
Driver.prototype.getConnection = function () {
    return this.db;
};
Object.defineProperty(Driver.prototype, "isSql", {
    value: true
});
function convertTimezone(tz) {
    if (tz === "Z") {
        return 0;
    }
    const m = tz.match(/([\+\-\s])(\d\d):?(\d\d)?/);
    if (m) {
        return (m[1] === '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;
    }
    return false;
}
//# sourceMappingURL=postgres.js.map