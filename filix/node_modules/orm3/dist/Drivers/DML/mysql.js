"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Driver = Driver;
const _ = __importStar(require("lodash"));
const mysql = require("mysql");
const SQLQuery_1 = require("../../SQLQuery");
const shared = __importStar(require("./_shared"));
const DDL = __importStar(require("../DDL/SQL"));
const resolveWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then((result) => cb(null, result)).catch((err) => cb(err));
        return;
    }
    return promise;
};
const resolveVoidWithCallback = (promise, cb) => {
    if (typeof cb === "function") {
        promise.then(() => cb(null)).catch((err) => cb(err));
        return;
    }
    return promise;
};
function Driver(config, connection, opts) {
    this.dialect = 'mysql';
    this.config = config || {};
    this.opts = opts || {};
    this.customTypes = {};
    if (!this.config.timezone) {
        this.config.timezone = "local";
    }
    this.query = (0, SQLQuery_1.Query)({ dialect: this.dialect, timezone: this.config.timezone });
    this.reconnect(null, connection);
    this.aggregate_functions = ["ABS", "CEIL", "FLOOR", "ROUND",
        "AVG", "MIN", "MAX",
        "LOG", "LOG2", "LOG10", "EXP", "POWER",
        "ACOS", "ASIN", "ATAN", "COS", "SIN", "TAN",
        "CONV", ["RANDOM", "RAND"], "RADIANS", "DEGREES",
        "SUM", "COUNT",
        "DISTINCT"];
}
_.extend(Driver.prototype, shared, DDL);
Driver.prototype.ping = function (cb) {
    const promise = new Promise((resolve, reject) => {
        this.db.ping((err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.on = function (ev, cb) {
    if (ev == "error") {
        this.db.on("error", cb);
        this.db.on("unhandledError", cb);
    }
    return this;
};
Driver.prototype.connect = function (cb) {
    const promise = new Promise((resolve, reject) => {
        if (this.opts.pool) {
            this.db.pool.getConnection((err, con) => {
                if (!err && con) {
                    if (typeof con.release === "function") {
                        con.release();
                    }
                    else if (typeof con.end === "function") {
                        con.end();
                    }
                }
                if (err)
                    return reject(err);
                resolve();
            });
            return;
        }
        this.db.connect((err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.reconnect = function (cb, connection) {
    var connOpts = this.config.href || this.config;
    // Prevent noisy mysql driver output
    if (typeof connOpts == 'object') {
        connOpts = _.omit(connOpts, 'debug');
    }
    if (typeof connOpts == 'string') {
        connOpts = connOpts.replace("debug=true", "debug=false");
    }
    this.db = (connection ? connection : mysql.createConnection(connOpts));
    if (this.opts.pool) {
        this.db.pool = (connection ? connection : mysql.createPool(connOpts));
    }
    if (typeof cb == "function") {
        this.connect(cb);
    }
};
Driver.prototype.close = function (cb) {
    const promise = new Promise((resolve, reject) => {
        const done = (err) => (err ? reject(err) : resolve());
        if (this.opts.pool) {
            this.db.pool.end(done);
        }
        else {
            this.db.end(done);
        }
    });
    return resolveVoidWithCallback(promise, cb);
};
Driver.prototype.getQuery = function () {
    return this.query;
};
Driver.prototype.execSimpleQuery = function (query, cb) {
    const promise = new Promise((resolve, reject) => {
        if (this.opts.debug) {
            require("../../Debug").sql('mysql', query);
        }
        const handleResult = (err, data) => {
            if (err)
                return reject(err);
            resolve(data);
        };
        if (this.opts.pool) {
            this.db.pool.getConnection((err, con) => {
                if (err)
                    return reject(err);
                const release = () => {
                    if (!con)
                        return;
                    if (typeof con.release === "function") {
                        con.release();
                    }
                    else if (typeof con.end === "function") {
                        con.end();
                    }
                };
                con.query(query, (queryErr, data) => {
                    release();
                    handleResult(queryErr, data);
                });
            });
        }
        else {
            this.db.query(query, handleResult);
        }
    });
    return resolveWithCallback(promise, cb);
};
Driver.prototype.find = function (fields, table, conditions, opts, cb) {
    var q = this.query.select()
        .from(table).select(fields);
    if (opts.offset) {
        q.offset(opts.offset);
    }
    if (typeof opts.limit == "number") {
        q.limit(opts.limit);
    }
    else if (opts.offset) {
        // OFFSET cannot be used without LIMIT so we use the biggest BIGINT number possible
        q.limit('18446744073709551615');
    }
    if (opts.order) {
        for (var i = 0; i < opts.order.length; i++) {
            q.order(opts.order[i][0], opts.order[i][1]);
        }
    }
    if (opts.merge) {
        q.from(opts.merge.from.table, opts.merge.from.field, opts.merge.to.field).select(opts.merge.select);
        if (opts.merge.where && Object.keys(opts.merge.where[1]).length) {
            q = q.where(opts.merge.where[0], opts.merge.where[1], opts.merge.table || null, conditions);
        }
        else {
            q = q.where(opts.merge.table || null, conditions);
        }
    }
    else {
        q = q.where(conditions);
    }
    if (opts.exists) {
        for (var k in opts.exists) {
            q.whereExists(opts.exists[k].table, table, opts.exists[k].link, opts.exists[k].conditions);
        }
    }
    q = q.build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.count = function (table, conditions, opts, cb) {
    var q = this.query.select()
        .from(table)
        .count(null, 'c');
    if (opts.merge) {
        q.from(opts.merge.from.table, opts.merge.from.field, opts.merge.to.field);
        if (opts.merge.where && Object.keys(opts.merge.where[1]).length) {
            q = q.where(opts.merge.where[0], opts.merge.where[1], conditions);
        }
        else {
            q = q.where(conditions);
        }
    }
    else {
        q = q.where(conditions);
    }
    if (opts.exists) {
        for (var k in opts.exists) {
            q.whereExists(opts.exists[k].table, table, opts.exists[k].link, opts.exists[k].conditions);
        }
    }
    q = q.build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.insert = function (table, data, keyProperties, cb) {
    var q = this.query.insert()
        .into(table)
        .set(data)
        .build();
    const promise = (async () => {
        const info = await this.execSimpleQuery(q);
        const ids = {};
        if (keyProperties) {
            if (keyProperties.length === 1 && Object.prototype.hasOwnProperty.call(info, "insertId") && info.insertId !== 0) {
                ids[keyProperties[0].name] = info.insertId;
            }
            else {
                for (let i = 0; i < keyProperties.length; i++) {
                    const prop = keyProperties[i];
                    ids[prop.name] = data[prop.mapsTo];
                }
            }
        }
        return ids;
    })();
    return resolveWithCallback(promise, cb);
};
Driver.prototype.update = function (table, changes, conditions, cb) {
    var q = this.query.update()
        .into(table)
        .set(changes)
        .where(conditions)
        .build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.remove = function (table, conditions, cb) {
    var q = this.query.remove()
        .from(table)
        .where(conditions)
        .build();
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.clear = function (table, cb) {
    var q = "TRUNCATE TABLE " + this.query.escapeId(table);
    const promise = this.execSimpleQuery(q);
    return resolveWithCallback(promise, cb);
};
Driver.prototype.valueToProperty = function (value, property) {
    var customType;
    switch (property.type) {
        case "boolean":
            value = !!value;
            break;
        case "object":
            if (typeof value == "object" && !Buffer.isBuffer(value)) {
                break;
            }
            try {
                value = JSON.parse(value);
            }
            catch (e) {
                value = null;
            }
            break;
        default:
            customType = this.customTypes[property.type];
            if (customType && 'valueToProperty' in customType) {
                value = customType.valueToProperty(value);
            }
    }
    return value;
};
Driver.prototype.propertyToValue = function (value, property) {
    var customType;
    switch (property.type) {
        case "boolean":
            value = (value) ? 1 : 0;
            break;
        case "object":
            if (value !== null) {
                value = JSON.stringify(value);
            }
            break;
        case "point":
            return function () { return 'POINT(' + value.x + ', ' + value.y + ')'; };
            break;
        default:
            customType = this.customTypes[property.type];
            if (customType && 'propertyToValue' in customType) {
                value = customType.propertyToValue(value);
            }
    }
    return value;
};
// ==================== IDriver Implementation ====================
/**
 * Get driver settings
 */
Driver.prototype.getSettings = function () {
    return {
        dataTypes: this.query.dataTypes || {},
        escapeId: (name) => this.query.escapeId(name),
        escapeVal: (val) => this.query.escape(val)
    };
};
/**
 * Define a model in the database (placeholder - uses DDL.sync pattern)
 */
Driver.prototype.define = function (definition) {
    // TODO: Implement explicit model definition if needed
    // Currently handled through sync() in DDL
};
/**
 * Get current database connection
 */
Driver.prototype.getConnection = function () {
    if (this.opts.pool) {
        return this.db.pool;
    }
    return this.db;
};
Object.defineProperty(Driver.prototype, "isSql", {
    value: true
});
//# sourceMappingURL=mysql.js.map