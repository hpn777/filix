"use strict";
/**
 * SQL DDL operations
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.sync = sync;
exports.drop = drop;
exports.getMetadata = getMetadata;
const _ = __importStar(require("lodash"));
const sync_1 = require("./sync");
const metadata_1 = require("./meta/mysql/metadata");
const metadata_2 = require("./meta/postgresql/metadata");
const metadata_3 = require("./meta/sqlite/metadata");
function sync(opts, cb) {
    const syncInstance = new sync_1.Sync({
        driver: this,
        debug: false
    });
    const setIndex = (p, v, k) => {
        v.index = true;
        p[k] = v;
    };
    if (this.customTypes) {
        for (const k in this.customTypes) {
            syncInstance.defineType(k, this.customTypes[k]);
        }
    }
    syncInstance.defineCollection(opts.table, opts.allProperties);
    for (let i = 0; i < opts.many_associations.length; i++) {
        let props = {};
        _.merge(props, opts.many_associations[i].mergeId);
        _.merge(props, opts.many_associations[i].mergeAssocId);
        props = _.transform(props, setIndex);
        _.merge(props, opts.many_associations[i].props);
        syncInstance.defineCollection(opts.many_associations[i].mergeTable, props);
    }
    syncInstance.sync((err) => {
        cb(err === null ? undefined : err);
    });
    return this;
}
function drop(opts, cb) {
    let i;
    const queries = [];
    let pending;
    queries.push("DROP TABLE IF EXISTS " + this.query.escapeId(opts.table));
    for (i = 0; i < opts.many_associations.length; i++) {
        queries.push("DROP TABLE IF EXISTS " + this.query.escapeId(opts.many_associations[i].mergeTable));
    }
    pending = queries.length;
    for (i = 0; i < queries.length; i++) {
        this.execQuery(queries[i], (err) => {
            if (--pending === 0) {
                return cb(err);
            }
        });
    }
    return this;
}
function getMetadata(options) {
    const cacheKey = options?.schema ?? '__default__';
    const cache = this.__metadataCache ?? new Map();
    if (cache.has(cacheKey)) {
        return cache.get(cacheKey);
    }
    const inspector = createMetadataDriver(this, options?.schema);
    cache.set(cacheKey, inspector);
    this.__metadataCache = cache;
    return inspector;
}
function createMetadataDriver(driver, schema) {
    switch (driver.dialect) {
        case 'mysql':
            return new metadata_1.MysqlMetadataDriver(driver, schema);
        case 'postgres':
        case 'postgresql':
            return new metadata_2.PostgresMetadataDriver(driver, schema);
        case 'sqlite':
            return new metadata_3.SqliteMetadataDriver(driver);
        default:
            throw new Error(`Metadata inspection is not supported for dialect '${driver.dialect}'`);
    }
}
exports.default = { sync, drop, getMetadata };
//# sourceMappingURL=SQL.js.map