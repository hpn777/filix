"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqliteMetadataDriver = void 0;
const table_1 = require("../table");
const column_1 = require("./column");
const index_1 = require("./index");
class SqliteMetadataDriver {
    constructor(driver) {
        this.driver = driver;
    }
    async getVersion() {
        const rows = await this.exec('SELECT sqlite_version() AS version');
        return rows[0]?.version;
    }
    async getTables() {
        const rows = await this.exec(`SELECT name AS table_name, UPPER(type) AS table_type FROM sqlite_master WHERE type IN ('table', 'view') AND name NOT LIKE 'sqlite_%';`);
        return rows.map((row) => new table_1.Table(row));
    }
    async getColumns(tableName) {
        const tableExpr = this.escape(tableName);
        const rows = await this.exec(`PRAGMA table_info(${tableExpr});`);
        const columns = rows.map((row) => new column_1.SqliteColumn(row));
        const uniqueColumns = await this.getUniqueColumnNames(tableName);
        for (const column of columns) {
            if (uniqueColumns.has(column.getName())) {
                column.markUnique();
            }
            if (column.isPrimaryKey() && /int/i.test(column.getDataType())) {
                column.markAutoIncrement();
            }
        }
        return columns;
    }
    async getIndexes(tableName) {
        const tableExpr = this.escape(tableName);
        const indexList = await this.exec(`PRAGMA index_list(${tableExpr});`);
        const indexes = [];
        for (const index of indexList) {
            const indexName = index.name;
            if (!indexName) {
                continue;
            }
            const indexExpr = this.escape(indexName);
            const indexInfo = await this.exec(`PRAGMA index_info(${indexExpr});`);
            for (const info of indexInfo) {
                indexes.push(new index_1.SqliteIndex({
                    index_name: indexName,
                    table_name: tableName,
                    name: info.name,
                }));
            }
        }
        return indexes;
    }
    async close() {
        // Metadata shares ORM connection; nothing to close.
        return Promise.resolve();
    }
    escape(value) {
        return this.driver.query.escapeVal(value);
    }
    async exec(sql) {
        const result = await this.driver.execSimpleQuery(sql);
        if (Array.isArray(result)) {
            return result;
        }
        return [];
    }
    async getUniqueColumnNames(tableName) {
        const tableExpr = this.escape(tableName);
        const indexList = await this.exec(`PRAGMA index_list(${tableExpr});`);
        const uniqueColumns = new Set();
        for (const index of indexList) {
            const uniqueValue = index.unique;
            const isUnique = uniqueValue === 1 || uniqueValue === '1' || uniqueValue === true;
            if (!isUnique) {
                continue;
            }
            const indexName = index.name;
            const indexExpr = this.escape(indexName);
            const indexInfo = await this.exec(`PRAGMA index_info(${indexExpr});`);
            for (const info of indexInfo) {
                if (info.name) {
                    uniqueColumns.add(String(info.name));
                }
            }
        }
        return uniqueColumns;
    }
}
exports.SqliteMetadataDriver = SqliteMetadataDriver;
//# sourceMappingURL=metadata.js.map