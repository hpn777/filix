"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MysqlMetadataDriver = void 0;
const table_1 = require("../table");
const column_1 = require("./column");
const index_1 = require("./index");
class MysqlMetadataDriver {
    constructor(driver, schemaOverride) {
        this.driver = driver;
        this.schemaOverride = schemaOverride;
    }
    async getVersion() {
        const rows = await this.exec("SELECT VERSION() AS version");
        return rows[0]?.version;
    }
    async getTables() {
        const schema = this.getSchema();
        const escapedSchema = this.escape(schema);
        const rows = await this.exec(`SELECT * FROM information_schema.tables WHERE table_schema = ${escapedSchema}`);
        return rows.map((row) => new table_1.Table(row));
    }
    async getColumns(tableName) {
        const schema = this.getSchema();
        const escapedSchema = this.escape(schema);
        const escapedTable = this.escape(tableName);
        const sql = `SELECT a.*, b.CONSTRAINT_NAME, b.REFERENCED_TABLE_NAME, b.REFERENCED_COLUMN_NAME, c.UPDATE_RULE, c.DELETE_RULE
      FROM INFORMATION_SCHEMA.COLUMNS a
      LEFT OUTER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE b
        ON a.table_schema = b.table_schema AND a.table_name = b.table_name AND a.column_name = b.column_name
      LEFT OUTER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS c
        ON c.CONSTRAINT_NAME = b.CONSTRAINT_NAME
      WHERE a.table_schema = ${escapedSchema} AND a.table_name = ${escapedTable}`;
        const rows = await this.exec(sql);
        return rows.map((row) => new column_1.MysqlColumn(row));
    }
    async getIndexes(tableName) {
        const schema = this.getSchema();
        const escapedSchema = this.escape(schema);
        const escapedTable = this.escape(tableName);
        const sql = `SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
      WHERE TABLE_SCHEMA = ${escapedSchema} AND TABLE_NAME = ${escapedTable}`;
        const rows = await this.exec(sql);
        return rows.map((row) => new index_1.MysqlIndex(row));
    }
    async close() {
        // Reuse existing ORM connection; no-op for metadata.
        return Promise.resolve();
    }
    escape(value) {
        return this.driver.query.escapeVal(value);
    }
    async exec(sql) {
        const result = await this.driver.execSimpleQuery(sql);
        if (Array.isArray(result)) {
            return result;
        }
        return [];
    }
    getSchema() {
        if (this.schemaOverride) {
            return this.schemaOverride;
        }
        const configDatabase = this.driver.config?.database;
        if (configDatabase) {
            return configDatabase;
        }
        const dbInstance = this.driver.db;
        if (dbInstance?.database) {
            return dbInstance.database;
        }
        if (dbInstance?.config?.database) {
            return dbInstance.config.database;
        }
        throw new Error('Unable to determine MySQL database/schema name for metadata inspection');
    }
}
exports.MysqlMetadataDriver = MysqlMetadataDriver;
//# sourceMappingURL=metadata.js.map