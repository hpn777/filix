"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getType = exports.removeIndex = exports.addIndex = exports.getCollectionIndexes = exports.dropCollectionColumn = exports.modifyCollectionColumn = exports.renameCollectionColumn = exports.addCollectionColumn = exports.dropCollection = exports.createCollection = exports.getCollectionProperties = exports.dropForeignKey = exports.addForeignKey = exports.dropPrimaryKey = exports.addPrimaryKey = exports.hasCollection = void 0;
const SQL = __importStar(require("../SQL"));
const columnSizes = {
    integer: { 2: "SMALLINT", 4: "INTEGER", 8: "BIGINT" },
    floating: { 4: "FLOAT", 8: "DOUBLE" },
};
const getNumericSize = (value, fallback) => {
    const numeric = Number(value);
    return Number.isFinite(numeric) ? numeric : fallback;
};
const hasCollection = (driver, name, cb) => {
    driver.execQuery("SHOW TABLES LIKE ?", [name], (err, rows) => {
        if (err) {
            cb(err);
            return;
        }
        cb(null, rows.length > 0);
    });
};
exports.hasCollection = hasCollection;
const addPrimaryKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? ADD CONSTRAINT ?? PRIMARY KEY(??);";
    driver.execQuery(sql, [tableName, `${columnName}PK`, columnName], cb);
};
exports.addPrimaryKey = addPrimaryKey;
const dropPrimaryKey = (driver, tableName, _columnName, cb) => {
    const sql = "ALTER TABLE ?? DROP PRIMARY KEY;";
    driver.execQuery(sql, [tableName], cb);
};
exports.dropPrimaryKey = dropPrimaryKey;
const addForeignKey = (driver, tableName, options, cb) => {
    const sql = " ALTER TABLE ?? ADD CONSTRAINT ?? FOREIGN KEY(??) REFERENCES ??(??)";
    driver.execQuery(sql, [tableName, `${options.name}_fk`, options.name, options.references.table, options.references.column], cb);
};
exports.addForeignKey = addForeignKey;
const dropForeignKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? DROP FOREIGN KEY ??;";
    driver.execQuery(sql, [tableName, `${columnName}_fk`], cb);
};
exports.dropForeignKey = dropForeignKey;
const getCollectionProperties = (driver, name, cb) => {
    driver.execQuery("SHOW COLUMNS FROM ??", [name], (err, cols) => {
        if (err) {
            cb(err);
            return;
        }
        const columns = {};
        for (let i = 0; i < cols.length; i += 1) {
            const dCol = cols[i];
            const column = {};
            if (dCol.Type.indexOf(" ") > 0) {
                dCol.SubType = dCol.Type.substr(dCol.Type.indexOf(" ") + 1).split(/\s+/);
                dCol.Type = dCol.Type.substr(0, dCol.Type.indexOf(" "));
            }
            const sizeMatch = dCol.Type.match(/^(.+)\((\d+)\)$/);
            if (sizeMatch) {
                dCol.Size = parseInt(sizeMatch[2], 10);
                dCol.Type = sizeMatch[1];
            }
            if (typeof dCol.Extra === "string" && dCol.Extra.toUpperCase() === "AUTO_INCREMENT") {
                column.serial = true;
                column.unsigned = true;
            }
            if (dCol.Key === "PRI") {
                column.primary = true;
            }
            if (typeof dCol.Null === "string" && dCol.Null.toUpperCase() === "NO") {
                column.required = true;
            }
            if (dCol.Default !== null && dCol.Default !== undefined) {
                column.defaultValue = dCol.Default;
            }
            switch ((dCol.Type || "").toUpperCase()) {
                case "SMALLINT":
                case "INTEGER":
                case "BIGINT":
                case "INT": {
                    column.type = "integer";
                    column.size = 4;
                    Object.keys(columnSizes.integer).forEach((key) => {
                        const numericKey = Number(key);
                        if (columnSizes.integer[numericKey] === dCol.Type.toUpperCase()) {
                            column.size = numericKey;
                        }
                    });
                    break;
                }
                case "FLOAT":
                case "DOUBLE": {
                    column.type = "number";
                    column.rational = true;
                    Object.keys(columnSizes.floating).forEach((key) => {
                        const numericKey = Number(key);
                        if (columnSizes.floating[numericKey] === dCol.Type.toUpperCase()) {
                            column.size = numericKey;
                        }
                    });
                    break;
                }
                case "TINYINT": {
                    if (dCol.Size === 1) {
                        column.type = "boolean";
                    }
                    else {
                        column.type = "integer";
                    }
                    break;
                }
                case "DATETIME": {
                    column.time = true;
                    column.type = "date";
                    break;
                }
                case "DATE": {
                    column.type = "date";
                    break;
                }
                case "LONGBLOB": {
                    column.big = true;
                    column.type = "binary";
                    break;
                }
                case "BLOB": {
                    column.type = "binary";
                    break;
                }
                case "VARCHAR": {
                    column.type = "text";
                    if (dCol.Size) {
                        column.size = dCol.Size;
                    }
                    break;
                }
                default: {
                    const enumMatch = dCol.Type.match(/^enum\('(.+)'\)$/i);
                    if (enumMatch) {
                        column.type = "enum";
                        column.values = enumMatch[1].split(/'\s*,\s*'/);
                        break;
                    }
                    cb(new Error(`Unknown column type '${dCol.Type}'`));
                    return;
                }
            }
            if (column.serial) {
                column.type = "serial";
            }
            columns[dCol.Field] = column;
        }
        cb(null, columns);
    });
};
exports.getCollectionProperties = getCollectionProperties;
const createCollection = (driver, name, columns, keys, cb) => {
    driver.execQuery(SQL.CREATE_TABLE({
        name,
        columns,
        keys,
    }, driver), cb);
};
exports.createCollection = createCollection;
const dropCollection = (driver, name, cb) => {
    driver.execQuery(SQL.DROP_TABLE({
        name,
    }, driver), cb);
};
exports.dropCollection = dropCollection;
const addCollectionColumn = (driver, name, column, afterColumn, cb) => {
    driver.execQuery(SQL.ALTER_TABLE_ADD_COLUMN({
        name,
        column,
        after: afterColumn ?? undefined,
        first: !afterColumn,
    }, driver), cb);
};
exports.addCollectionColumn = addCollectionColumn;
const renameCollectionColumn = (_driver, _name, _oldColName, _newColName, cb) => {
    cb(new Error("MySQL doesn't support simple column rename"));
};
exports.renameCollectionColumn = renameCollectionColumn;
const modifyCollectionColumn = (driver, name, column, cb) => {
    driver.execQuery(SQL.ALTER_TABLE_MODIFY_COLUMN({
        name,
        column,
    }, driver), cb);
};
exports.modifyCollectionColumn = modifyCollectionColumn;
const dropCollectionColumn = (driver, name, column, cb) => {
    driver.execQuery(SQL.ALTER_TABLE_DROP_COLUMN({
        name,
        column,
    }, driver), cb);
};
exports.dropCollectionColumn = dropCollectionColumn;
const getCollectionIndexes = (driver, name, cb) => {
    let q = "";
    q += "SELECT index_name, column_name, non_unique ";
    q += "FROM information_schema.statistics ";
    q += "WHERE table_schema = ? AND table_name = ?";
    driver.execQuery(q, [driver.config.database, name], (err, rows) => {
        if (err) {
            cb(err);
            return;
        }
        cb(null, convertIndexRows(rows));
    });
};
exports.getCollectionIndexes = getCollectionIndexes;
const addIndex = (driver, indexName, unique, collection, columns, cb) => {
    driver.execQuery(SQL.CREATE_INDEX({
        name: indexName,
        unique,
        collection,
        columns,
    }, driver), cb);
};
exports.addIndex = addIndex;
const removeIndex = (driver, collection, name, cb) => {
    driver.execQuery(SQL.DROP_INDEX({
        name,
        collection,
    }, driver), cb);
};
exports.removeIndex = removeIndex;
const getType = (collection, property, driver) => {
    let type = false;
    let customType = null;
    if (property.type === "number" && property.rational === false) {
        property.type = "integer";
        delete property.rational;
    }
    switch (property.type) {
        case "text":
            if (property.big) {
                type = "LONGTEXT";
            }
            else {
                const computedSize = Math.min(Math.max(getNumericSize(property.size, 255), 1), 65535);
                type = `VARCHAR(${computedSize})`;
            }
            break;
        case "integer":
            type = columnSizes.integer[getNumericSize(property.size, 4)];
            break;
        case "number":
            type = columnSizes.floating[getNumericSize(property.size, 4)];
            break;
        case "serial":
            property.type = "number";
            property.serial = true;
            property.key = true;
            type = "INT(11)";
            break;
        case "boolean":
            type = "TINYINT(1)";
            break;
        case "date":
            type = property.time ? "DATETIME" : "DATE";
            break;
        case "binary":
        case "object":
            type = property.big === true ? "LONGBLOB" : "BLOB";
            break;
        case "enum":
            if (!Array.isArray(property.values) || property.values.length === 0) {
                return false;
            }
            type = `ENUM (${property.values.map((val) => driver.query.escapeVal(val)).join(", ")})`;
            break;
        case "point":
            type = "POINT";
            break;
        default:
            customType = driver.customTypes ? driver.customTypes[property.type] : null;
            if (customType) {
                type = customType.datastoreType();
            }
    }
    if (!type) {
        return false;
    }
    if (property.required) {
        type += " NOT NULL";
    }
    if (property.serial) {
        if (!property.required) {
            type += " NOT NULL";
        }
        type += " AUTO_INCREMENT";
    }
    if (Object.prototype.hasOwnProperty.call(property, "defaultValue")) {
        type += ` DEFAULT ${driver.query.escapeVal(property.defaultValue)}`;
    }
    if (Object.prototype.hasOwnProperty.call(property, "defaultExpression")) {
        type += ` DEFAULT (${property.defaultExpression})`;
    }
    return {
        value: type,
        before: false,
    };
};
exports.getType = getType;
function convertIndexRows(rows) {
    const indexes = {};
    for (let i = 0; i < rows.length; i += 1) {
        const row = rows[i];
        if (row.index_name === "PRIMARY") {
            continue;
        }
        if (!Object.prototype.hasOwnProperty.call(indexes, row.index_name)) {
            indexes[row.index_name] = {
                columns: [],
                unique: row.non_unique === 0,
            };
        }
        indexes[row.index_name].columns.push(row.column_name);
    }
    return indexes;
}
exports.default = {
    hasCollection: exports.hasCollection,
    addPrimaryKey: exports.addPrimaryKey,
    dropPrimaryKey: exports.dropPrimaryKey,
    addForeignKey: exports.addForeignKey,
    dropForeignKey: exports.dropForeignKey,
    getCollectionProperties: exports.getCollectionProperties,
    createCollection: exports.createCollection,
    dropCollection: exports.dropCollection,
    addCollectionColumn: exports.addCollectionColumn,
    renameCollectionColumn: exports.renameCollectionColumn,
    modifyCollectionColumn: exports.modifyCollectionColumn,
    dropCollectionColumn: exports.dropCollectionColumn,
    getCollectionIndexes: exports.getCollectionIndexes,
    addIndex: exports.addIndex,
    removeIndex: exports.removeIndex,
    getType: exports.getType,
};
//# sourceMappingURL=mysql.js.map