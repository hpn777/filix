"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getType = exports.supportsType = exports.processKeys = exports.removeIndex = exports.addIndex = exports.getCollectionIndexes = exports.dropCollectionColumn = exports.modifyCollectionColumn = exports.renameCollectionColumn = exports.addCollectionColumn = exports.dropCollection = exports.createCollection = exports.getCollectionProperties = exports.dropForeignKey = exports.addForeignKey = exports.dropPrimaryKey = exports.addPrimaryKey = exports.hasCollection = void 0;
const Queue_1 = require("../Queue");
const SQL = __importStar(require("../SQL"));
const hasCollection = (driver, name, cb) => {
    driver.execQuery("SELECT * FROM sqlite_master WHERE type = 'table' and name = ?", [name], (err, rows) => {
        if (err) {
            cb(err);
            return;
        }
        cb(null, rows.length > 0);
    });
};
exports.hasCollection = hasCollection;
const addPrimaryKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? ADD CONSTRAINT ?? PRIMARY KEY(??);";
    driver.execQuery(sql, [tableName, `${columnName}PK`, columnName], cb);
};
exports.addPrimaryKey = addPrimaryKey;
const dropPrimaryKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? DROP CONSTRAINT ??;";
    driver.execQuery(sql, [tableName, `${columnName}PK`], cb);
};
exports.dropPrimaryKey = dropPrimaryKey;
const addForeignKey = (driver, tableName, options, cb) => {
    const sql = "ALTER TABLE ?? ADD FOREIGN KEY(??) REFERENCES ??(??);";
    driver.execQuery(sql, [tableName, options.name, options.references.table, options.references.column], cb);
};
exports.addForeignKey = addForeignKey;
const dropForeignKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? DROP CONSTRAINT ??;";
    driver.execQuery(sql, [tableName, `${tableName}_${columnName}_fkey`], cb);
};
exports.dropForeignKey = dropForeignKey;
const getCollectionProperties = (driver, name, cb) => {
    driver.execQuery("PRAGMA table_info(??)", [name], (err, cols) => {
        if (err) {
            cb(err);
            return;
        }
        const columns = {};
        for (let i = 0; i < cols.length; i += 1) {
            const dCol = cols[i];
            const column = {};
            if (dCol.pk) {
                column.key = true;
            }
            if (dCol.notnull) {
                column.required = true;
            }
            if (dCol.dflt_value) {
                const match = String(dCol.dflt_value).match(/^'(.*)'$/);
                if (match) {
                    column.defaultValue = match[1];
                }
                else {
                    column.defaultValue = match ? match[0] : dCol.dflt_value;
                }
            }
            switch ((dCol.type || "").toUpperCase()) {
                case "INTEGER": {
                    if (dCol.pk === 1) {
                        column.type = "serial";
                    }
                    else {
                        column.type = "integer";
                    }
                    break;
                }
                case "INTEGER UNSIGNED": {
                    column.type = "boolean";
                    break;
                }
                case "REAL": {
                    column.type = "number";
                    column.rational = true;
                    break;
                }
                case "DATETIME": {
                    column.type = "date";
                    column.time = true;
                    break;
                }
                case "BLOB": {
                    column.type = "binary";
                    column.big = true;
                    break;
                }
                case "TEXT": {
                    column.type = "text";
                    break;
                }
                default: {
                    cb(new Error(`Unknown column type '${dCol.type}'`));
                    return;
                }
            }
            columns[dCol.name] = column;
        }
        cb(null, columns);
    });
};
exports.getCollectionProperties = getCollectionProperties;
const createCollection = (driver, name, columns, keys, cb) => {
    driver.execQuery(SQL.CREATE_TABLE({
        name,
        columns,
        keys,
    }, driver), cb);
};
exports.createCollection = createCollection;
const dropCollection = (driver, name, cb) => {
    driver.execQuery(SQL.DROP_TABLE({
        name,
    }, driver), cb);
};
exports.dropCollection = dropCollection;
const addCollectionColumn = (driver, name, column, afterColumn, cb) => {
    driver.execQuery(SQL.ALTER_TABLE_ADD_COLUMN({
        name,
        column,
        after: afterColumn ?? undefined,
    }, driver), cb);
};
exports.addCollectionColumn = addCollectionColumn;
const renameCollectionColumn = (driver, name, oldColName, newColName, cb) => {
    const sql = SQL.ALTER_TABLE_RENAME_COLUMN({
        name,
        oldColName,
        newColName,
    }, driver);
    driver.execQuery(sql, cb);
};
exports.renameCollectionColumn = renameCollectionColumn;
const modifyCollectionColumn = (driver, name, column, cb) => {
    driver.execQuery(SQL.ALTER_TABLE_MODIFY_COLUMN({
        name,
        column,
    }, driver), cb);
};
exports.modifyCollectionColumn = modifyCollectionColumn;
const dropCollectionColumn = (_driver, _name, _column, cb) => {
    cb();
};
exports.dropCollectionColumn = dropCollectionColumn;
const getCollectionIndexes = (driver, name, cb) => {
    driver.execQuery(`PRAGMA index_list(${driver.query.escapeId(name)})`, (err, rows) => {
        if (err) {
            cb(err);
            return;
        }
        const indexes = convertIndexRows(rows);
        const queue = new Queue_1.Queue((queueErr) => {
            cb(queueErr, indexes);
        });
        Object.keys(indexes).forEach((key) => {
            if (key.match(/^sqlite_autoindex/)) {
                delete indexes[key];
                return;
            }
            queue.add((next) => {
                driver.execQuery(`PRAGMA index_info(${driver.query.escapeVal(key)})`, (infoErr, infoRows) => {
                    if (infoErr) {
                        next(infoErr);
                        return;
                    }
                    for (let i = 0; i < infoRows.length; i += 1) {
                        indexes[key].columns.push(infoRows[i].name);
                    }
                    next();
                });
            });
        });
        queue.check();
    });
};
exports.getCollectionIndexes = getCollectionIndexes;
const addIndex = (driver, name, unique, collection, columns, cb) => {
    driver.execQuery(SQL.CREATE_INDEX({
        name,
        unique,
        collection,
        columns,
    }, driver), cb);
};
exports.addIndex = addIndex;
const removeIndex = (driver, name, _collection, cb) => {
    driver.execQuery(`DROP INDEX IF EXISTS ${driver.query.escapeId(name)}`, cb);
};
exports.removeIndex = removeIndex;
const processKeys = (keys) => {
    if (keys.length === 1) {
        return [];
    }
    return keys;
};
exports.processKeys = processKeys;
const supportsType = (type) => {
    switch (type) {
        case "boolean":
        case "enum":
            return "number";
        default:
            return type;
    }
};
exports.supportsType = supportsType;
const getType = (_collection, property, driver) => {
    let type = false;
    let customType = null;
    if (property.type === "number" && property.rational === false) {
        property.type = "integer";
        delete property.rational;
    }
    switch (property.type) {
        case "text":
            type = "TEXT";
            break;
        case "integer":
            type = "INTEGER";
            break;
        case "number":
            type = "REAL";
            break;
        case "serial":
            property.serial = true;
            property.key = true;
            type = "INTEGER";
            break;
        case "boolean":
            type = "INTEGER UNSIGNED";
            break;
        case "date":
            type = "DATETIME";
            break;
        case "binary":
        case "object":
            type = "BLOB";
            break;
        case "enum":
            type = "INTEGER";
            break;
        case "point":
            type = "POINT";
            break;
        default:
            customType = driver.customTypes ? driver.customTypes[property.type] : null;
            if (customType) {
                type = customType.datastoreType();
            }
    }
    if (!type) {
        return false;
    }
    if (property.required) {
        type += " NOT NULL";
    }
    if (property.key) {
        if (!property.required) {
            type += " NOT NULL";
        }
        if (property.serial) {
            type += " PRIMARY KEY";
        }
    }
    if (property.serial) {
        if (!property.key) {
            type += " PRIMARY KEY";
        }
        type += " AUTOINCREMENT";
    }
    if (Object.prototype.hasOwnProperty.call(property, "defaultValue")) {
        type += ` DEFAULT ${driver.query.escapeVal(property.defaultValue)}`;
    }
    return {
        value: type,
        before: false,
    };
};
exports.getType = getType;
function convertIndexRows(rows) {
    const indexes = {};
    for (let i = 0; i < rows.length; i += 1) {
        const row = rows[i];
        if (!Object.prototype.hasOwnProperty.call(indexes, row.name)) {
            indexes[row.name] = {
                columns: [],
                unique: row.unique === 1,
            };
        }
    }
    return indexes;
}
exports.default = {
    hasCollection: exports.hasCollection,
    addPrimaryKey: exports.addPrimaryKey,
    dropPrimaryKey: exports.dropPrimaryKey,
    addForeignKey: exports.addForeignKey,
    dropForeignKey: exports.dropForeignKey,
    getCollectionProperties: exports.getCollectionProperties,
    createCollection: exports.createCollection,
    dropCollection: exports.dropCollection,
    addCollectionColumn: exports.addCollectionColumn,
    renameCollectionColumn: exports.renameCollectionColumn,
    modifyCollectionColumn: exports.modifyCollectionColumn,
    dropCollectionColumn: exports.dropCollectionColumn,
    getCollectionIndexes: exports.getCollectionIndexes,
    addIndex: exports.addIndex,
    removeIndex: exports.removeIndex,
    processKeys: exports.processKeys,
    supportsType: exports.supportsType,
    getType: exports.getType,
};
//# sourceMappingURL=sqlite.js.map