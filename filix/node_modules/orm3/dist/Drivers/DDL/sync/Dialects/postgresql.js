"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getType = exports.convertIndexes = exports.removeIndex = exports.addIndex = exports.getCollectionIndexes = exports.dropCollectionColumn = exports.modifyCollectionColumn = exports.renameCollectionColumn = exports.addCollectionColumn = exports.dropForeignKey = exports.addForeignKey = exports.dropPrimaryKey = exports.addPrimaryKey = exports.dropCollection = exports.createCollection = exports.getCollectionProperties = exports.getColumnProperties = exports.hasCollection = void 0;
const lodash_1 = __importDefault(require("lodash"));
const SQL = __importStar(require("../SQL"));
const Queue_1 = require("../Queue");
const columnSizes = {
    integer: { 2: "SMALLINT", 4: "INTEGER", 8: "BIGINT" },
    floating: { 4: "REAL", 8: "DOUBLE PRECISION" },
};
const getNumericSize = (value, fallback) => {
    const numeric = Number(value);
    return Number.isFinite(numeric) ? numeric : fallback;
};
const hasCollection = (driver, name, cb) => {
    driver.execQuery("SELECT * FROM information_schema.tables WHERE table_name = ?", [name], (err, rows) => {
        if (err) {
            cb(err);
            return;
        }
        cb(null, rows.length > 0);
    });
};
exports.hasCollection = hasCollection;
const getColumnProperties = (dCol) => {
    const column = {};
    const dataType = (dCol.data_type || "").toUpperCase();
    switch (dataType) {
        case "SMALLINT":
        case "INTEGER":
        case "BIGINT": {
            if (typeof dCol.column_default === "string" && dCol.column_default.indexOf("nextval(") === 0) {
                column.type = "serial";
            }
            else {
                column.type = "integer";
            }
            Object.keys(columnSizes.integer).forEach((key) => {
                const numericKey = Number(key);
                if (columnSizes.integer[numericKey] === dataType) {
                    column.size = numericKey;
                }
            });
            break;
        }
        case "REAL":
        case "DOUBLE PRECISION": {
            column.type = "number";
            column.rational = true;
            Object.keys(columnSizes.floating).forEach((key) => {
                const numericKey = Number(key);
                if (columnSizes.floating[numericKey] === dataType) {
                    column.size = numericKey;
                }
            });
            break;
        }
        case "BOOLEAN": {
            column.type = "boolean";
            break;
        }
        case "TIMESTAMP WITHOUT TIME ZONE": {
            column.time = true;
            column.type = "date";
            break;
        }
        case "DATE": {
            column.type = "date";
            break;
        }
        case "BYTEA": {
            column.type = "binary";
            break;
        }
        case "TEXT": {
            column.type = "text";
            break;
        }
        case "CHARACTER VARYING": {
            column.type = "text";
            if (dCol.character_maximum_length) {
                column.size = dCol.character_maximum_length;
            }
            break;
        }
        case "UUID": {
            column.type = "uuid";
            break;
        }
        case "USER-DEFINED": {
            if (typeof dCol.udt_name === "string" && dCol.udt_name.match(/_enum_/)) {
                column.type = "enum";
                column.values = [];
                break;
            }
            throw new Error(`Unknown column type '${dCol.data_type}'`);
        }
        default:
            throw new Error(`Unknown column type '${dCol.data_type}'`);
    }
    return column;
};
exports.getColumnProperties = getColumnProperties;
const getCollectionProperties = (driver, name, cb) => {
    driver.execQuery("SELECT * FROM information_schema.columns WHERE table_name = ?", [name], (err, cols) => {
        if (err) {
            cb(err);
            return;
        }
        const columns = {};
        for (let i = 0; i < cols.length; i += 1) {
            const dCol = cols[i];
            const column = {};
            if (typeof dCol.is_nullable === "string" && dCol.is_nullable.toUpperCase() === "NO") {
                column.required = true;
            }
            if (dCol.column_default !== null && dCol.column_default !== undefined) {
                const match = String(dCol.column_default).match(/^'(.+)'::/);
                if (match) {
                    column.defaultValue = match[1];
                }
                else {
                    column.defaultValue = dCol.column_default;
                }
            }
            try {
                lodash_1.default.extend(column, (0, exports.getColumnProperties)(dCol));
            }
            catch (error) {
                cb(error);
                return;
            }
            columns[dCol.column_name] = column;
        }
        checkColumnTypes(driver, name, columns, cb);
    });
};
exports.getCollectionProperties = getCollectionProperties;
const createCollection = (driver, name, columns, keys, cb) => {
    driver.execQuery(SQL.CREATE_TABLE({
        name,
        columns,
        keys,
    }, driver), cb);
};
exports.createCollection = createCollection;
const dropCollection = (driver, name, cb) => {
    driver.execQuery(SQL.DROP_TABLE({
        name,
    }, driver), cb);
};
exports.dropCollection = dropCollection;
const addPrimaryKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? ADD CONSTRAINT ?? PRIMARY KEY(??);";
    driver.execQuery(sql, [tableName, `${tableName}_${columnName}_pk`, columnName], cb);
};
exports.addPrimaryKey = addPrimaryKey;
const dropPrimaryKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? DROP CONSTRAINT ??;";
    driver.execQuery(sql, [tableName, `${tableName}_${columnName}_pk`], cb);
};
exports.dropPrimaryKey = dropPrimaryKey;
const addForeignKey = (driver, tableName, options, cb) => {
    const sql = "ALTER TABLE ?? ADD FOREIGN KEY(??) REFERENCES ?? (??);";
    driver.execQuery(sql, [tableName, options.name, options.references.table, options.references.column], cb);
};
exports.addForeignKey = addForeignKey;
const dropForeignKey = (driver, tableName, columnName, cb) => {
    const sql = "ALTER TABLE ?? DROP CONSTRAINT ??;";
    driver.execQuery(sql, [tableName, `${tableName}_${columnName}_fkey`], cb);
};
exports.dropForeignKey = dropForeignKey;
const addCollectionColumn = (driver, name, column, _afterColumn, cb) => {
    const sql = "ALTER TABLE ?? ADD " + column + ";";
    driver.execQuery(sql, [name], cb);
};
exports.addCollectionColumn = addCollectionColumn;
const renameCollectionColumn = (driver, name, oldColName, newColName, cb) => {
    const sql = SQL.ALTER_TABLE_RENAME_COLUMN({
        name,
        oldColName,
        newColName,
    }, driver);
    driver.execQuery(sql, cb);
};
exports.renameCollectionColumn = renameCollectionColumn;
const modifyCollectionColumn = (driver, name, column, cb) => {
    const firstSpace = column.indexOf(" ");
    const colName = column.substr(0, firstSpace);
    const queue = new Queue_1.Queue(cb);
    let remainder = column.substr(firstSpace + 1);
    let colType = remainder;
    const secondSpace = remainder.indexOf(" ");
    if (secondSpace > 0) {
        colType = remainder.substr(0, secondSpace);
        remainder = remainder.substr(secondSpace + 1);
    }
    else {
        remainder = "";
    }
    queue.add((next) => {
        driver.execQuery(`ALTER TABLE ${name} ALTER ${colName} TYPE ${colType}`, next);
    });
    if (remainder) {
        if (remainder.match(/NOT NULL/)) {
            queue.add((next) => {
                driver.execQuery(`ALTER TABLE ${name} ALTER ${colName} SET NOT NULL`, next);
            });
        }
        else {
            queue.add((next) => {
                driver.execQuery(`ALTER TABLE ${name} ALTER ${colName} DROP NOT NULL`, next);
            });
        }
        const defaultMatch = remainder.match(/DEFAULT (.+)$/);
        if (defaultMatch) {
            queue.add((next) => {
                driver.execQuery(`ALTER TABLE ${name} ALTER ${colName} SET DEFAULT ${defaultMatch[1]}`, next);
            });
        }
    }
    queue.check();
};
exports.modifyCollectionColumn = modifyCollectionColumn;
const dropCollectionColumn = (driver, name, column, cb) => {
    driver.execQuery(SQL.ALTER_TABLE_DROP_COLUMN({
        name,
        column,
    }, driver), cb);
};
exports.dropCollectionColumn = dropCollectionColumn;
const getCollectionIndexes = (driver, name, cb) => {
    const sql = "SELECT t.relname, i.relname, a.attname, ix.indisunique, ix.indisprimary " +
        "FROM pg_class t, pg_class i, pg_index ix, pg_attribute a " +
        "WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid " +
        "AND a.attrelid = t.oid AND a.attnum = ANY(ix.indkey) " +
        "AND t.relkind = 'r' AND t.relname = ?";
    driver.execQuery(sql, [name], (err, rows) => {
        if (err) {
            cb(err);
            return;
        }
        cb(null, convertIndexRows(rows));
    });
};
exports.getCollectionIndexes = getCollectionIndexes;
const addIndex = (driver, name, unique, collection, columns, cb) => {
    driver.execQuery(SQL.CREATE_INDEX({
        name,
        unique,
        collection,
        columns,
    }, driver), cb);
};
exports.addIndex = addIndex;
const removeIndex = (driver, _collection, name, cb) => {
    driver.execQuery(`DROP INDEX ${driver.query.escapeId(name)}`, cb);
};
exports.removeIndex = removeIndex;
const convertIndexes = (collection, indexes) => {
    for (let i = 0; i < indexes.length; i += 1) {
        indexes[i].name = `${collection.name}_${indexes[i].name}`;
    }
    return indexes;
};
exports.convertIndexes = convertIndexes;
const getType = (collection, property, driver) => {
    let type = false;
    let before = false;
    let customType = null;
    if (property.type === "number" && property.rational === false) {
        property.type = "integer";
        delete property.rational;
    }
    if (property.serial) {
        type = "SERIAL";
    }
    else {
        switch (property.type) {
            case "text":
                type = "TEXT";
                break;
            case "integer":
                type = columnSizes.integer[getNumericSize(property.size, 4)];
                break;
            case "number":
                type = columnSizes.floating[getNumericSize(property.size, 4)];
                break;
            case "serial":
                property.serial = true;
                property.key = true;
                type = "SERIAL";
                break;
            case "boolean":
                type = "BOOLEAN";
                break;
            case "date":
                type = property.time ? "TIMESTAMP WITHOUT TIME ZONE" : "DATE";
                break;
            case "binary":
            case "object":
                type = "BYTEA";
                break;
            case "enum": {
                type = `${collection}_enum_${String(property.mapsTo || "").toLowerCase()}`;
                if (!Array.isArray(property.values) || property.values.length === 0) {
                    return false;
                }
                before = (drv, next) => {
                    const enumType = `${collection}_enum_${String(property.mapsTo || "").toLowerCase()}`;
                    drv.execQuery("SELECT * FROM pg_catalog.pg_type WHERE typname = ?", [enumType], (err, rows) => {
                        if (!err && rows.length) {
                            next();
                            return;
                        }
                        const values = property.values.map((val) => drv.query.escapeVal(val));
                        drv.execQuery(`CREATE TYPE ${enumType} AS ENUM (${values.join(", ")})`, next);
                    });
                };
                break;
            }
            case "point":
                type = "POINT";
                break;
            case "uuid":
                type = "UUID";
                break;
            default:
                customType = driver.customTypes ? driver.customTypes[property.type] : null;
                if (customType) {
                    type = customType.datastoreType();
                }
        }
        if (!type) {
            return false;
        }
        if (property.required) {
            type += " NOT NULL";
        }
        if (Object.prototype.hasOwnProperty.call(property, "defaultValue")) {
            if (property.type === "date" && property.defaultValue === Date.now) {
                type += " DEFAULT now()";
            }
            else {
                let defaultValue = property.defaultValue;
                if (property.type === "boolean") {
                    if (typeof defaultValue === "string") {
                        const normalized = defaultValue.trim().toLowerCase();
                        defaultValue = ["true", "1", "t", "yes", "y"].includes(normalized);
                    }
                    else {
                        defaultValue = Boolean(defaultValue);
                    }
                }
                type += ` DEFAULT ${driver.query.escapeVal(defaultValue)}`;
            }
        }
        if (Object.prototype.hasOwnProperty.call(property, "defaultExpression")) {
            type += ` DEFAULT ${property.defaultExpression}`;
        }
    }
    return {
        value: type,
        before,
    };
};
exports.getType = getType;
function convertIndexRows(rows) {
    const indexes = {};
    for (let i = 0; i < rows.length; i += 1) {
        const row = rows[i];
        if (row.indisprimary) {
            continue;
        }
        if (!Object.prototype.hasOwnProperty.call(indexes, row.relname)) {
            indexes[row.relname] = {
                columns: [],
                unique: row.indisunique,
            };
        }
        indexes[row.relname].columns.push(row.attname);
    }
    return indexes;
}
function checkColumnTypes(driver, collection, columns, cb) {
    const queue = new Queue_1.Queue((err) => {
        if (err) {
            cb(err);
            return;
        }
        cb(null, columns);
    });
    Object.keys(columns).forEach((key) => {
        if (columns[key].type === "enum") {
            queue.add((next) => {
                const colName = `${collection}_enum_${key}`;
                driver.execQuery("SELECT t.typname, string_agg(e.enumlabel, '|' ORDER BY e.enumsortorder) AS enum_values " +
                    "FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid = e.enumtypid  " +
                    "WHERE t.typname = ? GROUP BY 1", [colName], (err, rows) => {
                    if (err) {
                        next(err);
                        return;
                    }
                    if (rows.length) {
                        columns[key].values = rows[0].enum_values.split("|");
                    }
                    next();
                });
            });
        }
    });
    queue.check();
}
exports.default = {
    hasCollection: exports.hasCollection,
    getColumnProperties: exports.getColumnProperties,
    getCollectionProperties: exports.getCollectionProperties,
    createCollection: exports.createCollection,
    dropCollection: exports.dropCollection,
    addPrimaryKey: exports.addPrimaryKey,
    dropPrimaryKey: exports.dropPrimaryKey,
    addForeignKey: exports.addForeignKey,
    dropForeignKey: exports.dropForeignKey,
    addCollectionColumn: exports.addCollectionColumn,
    renameCollectionColumn: exports.renameCollectionColumn,
    modifyCollectionColumn: exports.modifyCollectionColumn,
    dropCollectionColumn: exports.dropCollectionColumn,
    getCollectionIndexes: exports.getCollectionIndexes,
    addIndex: exports.addIndex,
    removeIndex: exports.removeIndex,
    convertIndexes: exports.convertIndexes,
    getType: exports.getType,
};
//# sourceMappingURL=postgresql.js.map