"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dialect = exports.Sync = void 0;
const lodash_1 = __importDefault(require("lodash"));
const Queue_1 = require("./Queue");
const mysql_1 = __importDefault(require("./Dialects/mysql"));
const postgresql_1 = __importDefault(require("./Dialects/postgresql"));
const questdb_1 = __importDefault(require("./Dialects/questdb"));
const sqlite_1 = __importDefault(require("./Dialects/sqlite"));
const DIALECTS = {
    mysql: mysql_1.default,
    postgresql: postgresql_1.default,
    questdb: questdb_1.default,
    sqlite: sqlite_1.default,
};
const noOp = () => { };
class Sync {
    constructor(options) {
        this.collections = [];
        this.types = {};
        this.totalChanges = 0;
        this.driver = options.driver;
        this.debug = typeof options.debug === "function" ? options.debug : noOp;
        this.suppressColumnDrop = Boolean(options.suppressColumnDrop);
        const dialectName = this.driver && (this.driver.ddlDialect || this.driver.dialect);
        this.dialect = DIALECTS[dialectName];
        if (!this.dialect) {
            throw new Error(`Unsupported dialect '${dialectName}'`);
        }
    }
    defineCollection(collection, properties) {
        this.collections.push({
            name: collection,
            properties,
        });
        return this;
    }
    defineType(type, definition) {
        this.types[type] = definition;
        return this;
    }
    sync(cb) {
        let index = 0;
        const processNext = () => {
            if (index >= this.collections.length) {
                cb(null, { changes: this.totalChanges });
                return;
            }
            const collection = this.collections[index++];
            this.processCollection(collection, (err) => {
                if (err) {
                    cb(err);
                    return;
                }
                processNext();
            });
        };
        this.totalChanges = 0;
        processNext();
    }
    processCollection(collection, cb) {
        this.dialect.hasCollection(this.driver, collection.name, (err, has) => {
            if (err) {
                cb(err);
                return;
            }
            if (!has) {
                this.createCollection(collection, cb);
                return;
            }
            // Legacy path from original module intentionally skipped (see upstream comments)
            cb(null, false);
        });
    }
    createCollection(collection, cb) {
        const columns = [];
        const keys = [];
        const before = [];
        const nextBefore = () => {
            if (before.length === 0) {
                this.dialect.createCollection(this.driver, collection.name, columns, keys, (err) => {
                    if (err) {
                        cb(err);
                        return;
                    }
                    this.syncIndexes(collection.name, this.getCollectionIndexes(collection), cb);
                });
                return;
            }
            const next = before.shift();
            if (!next) {
                nextBefore();
                return;
            }
            next(this.driver, (err) => {
                if (err) {
                    cb(err);
                    return;
                }
                nextBefore();
            });
        };
        const propertyKeys = Object.keys(collection.properties);
        for (const key of propertyKeys) {
            const prop = collection.properties[key];
            prop.mapsTo = prop.mapsTo || key;
            const column = this.createColumn(collection.name, prop);
            if (column === false) {
                cb(new Error(`Unknown type for property '${key}'`));
                return;
            }
            if (prop.key) {
                keys.push(prop.mapsTo);
            }
            columns.push(column.value);
            if (column.before && typeof column.before === "function") {
                before.push(column.before);
            }
        }
        this.debug(`Creating ${collection.name}`);
        if (typeof this.dialect.processKeys === "function") {
            const processed = this.dialect.processKeys(keys);
            if (Array.isArray(processed)) {
                keys.splice(0, keys.length, ...processed);
            }
        }
        this.totalChanges += 1;
        nextBefore();
    }
    createColumn(collection, prop) {
        let type = null;
        if (Object.prototype.hasOwnProperty.call(this.types, prop.type)) {
            type = this.types[prop.type].datastoreType(prop);
        }
        else {
            type = this.dialect.getType(collection, prop, this.driver);
        }
        if (type === false || type === null || type === undefined) {
            return false;
        }
        const column = typeof type === "string" ? { value: type } : type;
        if (prop.mapsTo === undefined) {
            // eslint-disable-next-line no-console
            console.log("undefined prop.mapsTo", prop, new Error().stack);
        }
        const value = `${this.driver.query.escapeId(prop.mapsTo)} ${column.value}`;
        return {
            value,
            before: column.before ?? false,
        };
    }
    syncIndexes(name, indexes, cb) {
        if (!indexes.length) {
            cb(null);
            return;
        }
        this.dialect.getCollectionIndexes(this.driver, name, (err, dbIndexes) => {
            if (err) {
                cb(err);
                return;
            }
            const queue = new Queue_1.Queue(cb);
            for (let i = 0; i < indexes.length; i += 1) {
                const index = indexes[i];
                if (!Object.prototype.hasOwnProperty.call(dbIndexes, index.name)) {
                    this.debug(`Adding index ${name}.${index.name} (${index.columns.join(", ")})`);
                    this.totalChanges += 1;
                    queue.add((next) => {
                        this.dialect.addIndex(this.driver, index.name, index.unique, name, index.columns, next);
                    });
                    continue;
                }
                if (!dbIndexes[index.name].unique !== !index.unique) {
                    this.debug(`Replacing index ${name}.${index.name}`);
                    this.totalChanges += 1;
                    queue.add((next) => {
                        this.dialect.removeIndex(this.driver, index.name, name, next);
                    });
                    queue.add((next) => {
                        this.dialect.addIndex(this.driver, index.name, index.unique, name, index.columns, next);
                    });
                }
                delete dbIndexes[index.name];
            }
            Object.keys(dbIndexes).forEach((indexName) => {
                this.debug(`Removing index ${name}.${indexName}`);
                this.totalChanges += 1;
                queue.add((next) => {
                    this.dialect.removeIndex(this.driver, indexName, name, next);
                });
            });
            queue.check();
        });
    }
    getCollectionIndexes(collection) {
        const indexes = [];
        for (const key of Object.keys(collection.properties)) {
            const prop = collection.properties[key];
            prop.name = prop.name || key;
            if (prop.unique) {
                const uniqueValues = Array.isArray(prop.unique) ? prop.unique : [prop.unique];
                for (const uniqueIndex of uniqueValues) {
                    if (uniqueIndex === true) {
                        indexes.push({
                            name: this.getIndexName(collection, prop),
                            unique: true,
                            columns: [key],
                        });
                        continue;
                    }
                    let found = false;
                    for (let i = 0; i < indexes.length; i += 1) {
                        if (indexes[i].name === uniqueIndex) {
                            indexes[i].columns.push(key);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        indexes.push({
                            name: uniqueIndex,
                            unique: true,
                            columns: [key],
                        });
                    }
                }
            }
            if (prop.index) {
                const indexValues = Array.isArray(prop.index) ? prop.index : [prop.index];
                for (const indexValue of indexValues) {
                    if (indexValue === true) {
                        indexes.push({
                            name: this.getIndexName(collection, prop),
                            columns: [key],
                        });
                        continue;
                    }
                    let found = false;
                    for (let i = 0; i < indexes.length; i += 1) {
                        if (indexes[i].name === indexValue) {
                            indexes[i].columns.push(key);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        indexes.push({
                            name: indexValue,
                            columns: [key],
                        });
                    }
                }
            }
        }
        if (typeof this.dialect.convertIndexes === "function") {
            return this.dialect.convertIndexes(collection, indexes);
        }
        return indexes;
    }
    getIndexName(collection, prop) {
        const postfix = prop.unique ? "unique" : "index";
        if (this.driver.dialect === "sqlite") {
            return `${collection.name}_${prop.name}_${postfix}`;
        }
        return `${prop.name}_${postfix}`;
    }
    needToSync(property, column) {
        if (property.serial && property.type === "number") {
            property.type = "serial";
        }
        if (property.type !== column.type) {
            if (typeof this.dialect.supportsType !== "function") {
                return true;
            }
            if (this.dialect.supportsType(property.type) !== column.type) {
                return true;
            }
        }
        if (property.type === "serial") {
            return false;
        }
        if (property.required !== column.required && !property.key) {
            return true;
        }
        if (Object.prototype.hasOwnProperty.call(property, "defaultValue") && property.defaultValue !== column.defaultValue) {
            return true;
        }
        if ((property.type === "number" || property.type === "integer") && Object.prototype.hasOwnProperty.call(column, "size")) {
            const propertySize = property.size || 4;
            if (propertySize !== column.size) {
                return true;
            }
        }
        if (property.type === "enum" && column.type === "enum") {
            const differenceA = lodash_1.default.difference(property.values || [], column.values || []);
            const differenceB = lodash_1.default.difference(column.values || [], property.values || []);
            if (differenceA.length > 0 || differenceB.length > 0) {
                return true;
            }
        }
        return false;
    }
    syncCollection(collection, columns, cb) {
        const queue = new Queue_1.Queue(cb);
        let lastKey = null;
        this.debug(`Synchronizing ${collection.name}`);
        for (const key of Object.keys(collection.properties)) {
            const property = collection.properties[key];
            if (!Object.prototype.hasOwnProperty.call(columns, key)) {
                const column = this.createColumn(collection.name, property);
                if (column === false) {
                    queue.add((next) => {
                        next(new Error(`Unknown type for property '${key}'`));
                    });
                    lastKey = key;
                    continue;
                }
                this.debug(`Adding column ${collection.name}.${key}: ${column.value}`);
                this.totalChanges += 1;
                const beforeHook = column.before;
                if (beforeHook) {
                    queue.add((next) => {
                        beforeHook(this.driver, (err) => {
                            if (err) {
                                next(err);
                                return;
                            }
                            this.dialect.addCollectionColumn(this.driver, collection.name, column.value, lastKey, next);
                        });
                    });
                }
                else {
                    queue.add((next) => {
                        this.dialect.addCollectionColumn(this.driver, collection.name, column.value, lastKey, next);
                    });
                }
            }
            else if (this.needToSync(property, columns[key])) {
                const column = this.createColumn(collection.name, property);
                if (column === false) {
                    queue.add((next) => {
                        next(new Error(`Unknown type for property '${key}'`));
                    });
                    lastKey = key;
                    continue;
                }
                this.debug(`Modifying column ${collection.name}.${key}: ${column.value}`);
                this.totalChanges += 1;
                const beforeHook = column.before;
                if (beforeHook) {
                    queue.add((next) => {
                        beforeHook(this.driver, (err) => {
                            if (err) {
                                next(err);
                                return;
                            }
                            this.dialect.modifyCollectionColumn(this.driver, collection.name, column.value, next);
                        });
                    });
                }
                else {
                    queue.add((next) => {
                        this.dialect.modifyCollectionColumn(this.driver, collection.name, column.value, next);
                    });
                }
            }
            lastKey = key;
        }
        if (!this.suppressColumnDrop) {
            for (const key of Object.keys(columns)) {
                if (!Object.prototype.hasOwnProperty.call(collection.properties, key)) {
                    queue.add((next) => {
                        this.debug(`Dropping column ${collection.name}.${key}`);
                        this.totalChanges += 1;
                        this.dialect.dropCollectionColumn(this.driver, collection.name, key, next);
                    });
                }
            }
        }
        const indexes = this.getCollectionIndexes(collection);
        if (indexes.length) {
            queue.add((next) => {
                this.syncIndexes(collection.name, indexes, next);
            });
        }
        queue.check();
    }
}
exports.Sync = Sync;
const dialect = (name) => {
    const module = DIALECTS[name];
    if (!module) {
        throw new Error(`Unknown SQL DDL dialect '${name}'`);
    }
    return module;
};
exports.dialect = dialect;
exports.default = {
    Sync,
    dialect: exports.dialect,
};
//# sourceMappingURL=index.js.map