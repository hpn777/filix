"use strict";
/**
 * Chain Find - Fluent interface for querying (Promise-based)
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainFind = ChainFind;
const _ = __importStar(require("lodash"));
const Utilities = __importStar(require("./Utilities"));
const ChainInstance_1 = __importDefault(require("./ChainInstance"));
function ChainFind(Model, opts) {
    const ensureNoCallback = (method, args) => {
        if (!args || args.length === 0) {
            return;
        }
        const lastArg = args[args.length - 1];
        if (typeof lastArg === 'function') {
            throw new Error(`${method} no longer accepts callback arguments. Use the returned promise instead.`);
        }
    };
    const resolveNewInstance = async (data) => {
        if (opts.newInstance.length >= 2) {
            return await new Promise((resolve, reject) => {
                opts.newInstance(data, (err, instance) => {
                    if (err) {
                        return reject(err);
                    }
                    resolve(instance);
                });
            });
        }
        const result = opts.newInstance(data);
        if (result && typeof result.then === 'function') {
            return result;
        }
        throw new Error('newInstance must return a Promise when callbacks are removed.');
    };
    const prepareConditions = () => {
        return Utilities.transformPropertyNames(opts.conditions || {}, opts.properties);
    };
    const prepareOrder = () => {
        return Utilities.transformOrderPropertyNames((opts.order || []), opts.properties);
    };
    const executeFind = async (fields, tableName, conditions, options) => {
        const driver = opts.driver;
        const rows = await driver.find(fields, tableName, conditions, options);
        return rows || [];
    };
    const executeCount = async (tableName, conditions, options) => {
        const driver = opts.driver;
        const data = await driver.count(tableName, conditions, options);
        if (!data || data.length === 0) {
            return 0;
        }
        const row = data[0];
        const value = row?.c ?? row?.count ?? row?.C ?? row?.COUNT;
        if (typeof value === 'number') {
            return value;
        }
        if (typeof value === 'string') {
            const parsed = parseInt(value, 10);
            return isNaN(parsed) ? 0 : parsed;
        }
        return 0;
    };
    const executeRemove = async (tableName, conditions) => {
        const driver = opts.driver;
        await driver.remove(tableName, conditions);
    };
    /**
     * Internal async chain execution
     * Retrieves instances with optional eager loading
     */
    const chainRun = async () => {
        // Fetch raw data from driver
        const dataItems = await executeFind(opts.only || opts.keys, opts.table, prepareConditions(), {
            limit: opts.limit,
            order: prepareOrder(),
            merge: opts.merge,
            offset: opts.offset,
            exists: opts.exists
        });
        if (!dataItems || dataItems.length === 0) {
            return [];
        }
        // Convert raw data to model instances
        const instances = [];
        for (const item of dataItems) {
            const instance = await resolveNewInstance(item);
            instances.push(instance);
        }
        // Handle eager loading associations
        if (opts.__eager && opts.__eager.length > 0 && typeof opts.driver.eagerQuery === 'function') {
            const idMap = {};
            const primaryKey = opts.keys[0];
            const keys = instances.map((instance, index) => {
                const key = instance[primaryKey];
                idMap[key] = index;
                return key;
            });
            for (const association of opts.__eager) {
                for (const instance of instances) {
                    instance[association.name] = [];
                }
                const assocRows = await new Promise((resolve, reject) => {
                    try {
                        const result = opts.driver.eagerQuery(association, opts, keys, (err, rows) => {
                            if (err)
                                return reject(err);
                            resolve(rows || []);
                        });
                        if (result && typeof result.then === 'function') {
                            result.then(resolve).catch(reject);
                        }
                    }
                    catch (err) {
                        reject(err);
                    }
                });
                for (const row of assocRows) {
                    const parentIndex = idMap[row.$p];
                    if (typeof parentIndex === 'undefined') {
                        continue;
                    }
                    const targetInstance = instances[parentIndex];
                    const associatedInstance = new association.model(row);
                    targetInstance[association.name].push(associatedInstance);
                }
            }
        }
        return instances;
    };
    const chain = {
        find(...args) {
            ensureNoCallback('find', args);
            opts.conditions = opts.conditions || {};
            if (typeof args[0] === "object") {
                _.extend(opts.conditions, args[0]);
            }
            else if (typeof args[0] === "string") {
                opts.conditions.__sql = opts.conditions.__sql || [];
                opts.conditions.__sql.push(args);
            }
            return this;
        },
        only(...args) {
            if (arguments.length && Array.isArray(arguments[0])) {
                opts.only = arguments[0];
            }
            else {
                opts.only = Array.prototype.slice.apply(arguments);
            }
            return this;
        },
        omit(...args) {
            let omit;
            if (arguments.length && Array.isArray(arguments[0])) {
                omit = arguments[0];
            }
            else {
                omit = Array.prototype.slice.apply(arguments);
            }
            this.only(_.difference(Object.keys(opts.properties), omit));
            return this;
        },
        limit(limit) {
            opts.limit = limit;
            return this;
        },
        skip(offset) {
            return this.offset(offset);
        },
        offset(offset) {
            opts.offset = offset;
            return this;
        },
        order(property, order) {
            if (!Array.isArray(opts.order)) {
                opts.order = [];
            }
            if (property[0] === "-") {
                opts.order.push([property.substr(1), "Z"]);
            }
            else {
                opts.order.push([property, (order && order.toUpperCase() === "Z" ? "Z" : "A")]);
            }
            return this;
        },
        orderRaw(str, args) {
            if (!Array.isArray(opts.order)) {
                opts.order = [];
            }
            opts.order.push([str, args || []]);
            return this;
        },
        count(...args) {
            ensureNoCallback('count', args);
            return executeCount(opts.table, prepareConditions(), {
                merge: opts.merge,
                exists: opts.exists
            });
        },
        remove(...args) {
            ensureNoCallback('remove', args);
            const keys = _.map(opts.keyProperties, 'mapsTo');
            const promise = executeFind(keys, opts.table, prepareConditions(), {
                limit: opts.limit,
                order: prepareOrder(),
                merge: opts.merge,
                offset: opts.offset,
                exists: opts.exists
            }).then((data) => {
                if (!data || data.length === 0) {
                    return;
                }
                const conditions = { or: [] };
                for (let i = 0; i < data.length; i++) {
                    const or = {};
                    for (let j = 0; j < opts.keys.length; j++) {
                        or[keys[j]] = data[i][keys[j]];
                    }
                    conditions.or.push(or);
                }
                return executeRemove(opts.table, conditions);
            });
            return promise;
        },
        first(...args) {
            ensureNoCallback('first', args);
            return this.run().then((items) => {
                return items && items.length > 0 ? items[0] : null;
            });
        },
        last(...args) {
            ensureNoCallback('last', args);
            return this.run().then((items) => {
                return items && items.length > 0 ? items[items.length - 1] : null;
            });
        },
        each(cb) {
            return (0, ChainInstance_1.default)(() => this.run(), cb);
        },
        run(...args) {
            ensureNoCallback('run', args);
            return chainRun();
        },
        eager(...args) {
            const associations = _.flatten(args);
            opts.__eager = _.filter(opts.associations || [], (association) => {
                return ~associations.indexOf(association.name);
            });
            return this;
        }
    };
    chain.all = chain.where = chain.find;
    if (opts.associations) {
        for (const association of opts.associations) {
            addChainMethod(chain, association, opts);
        }
    }
    for (const k in Model) {
        if ([
            "hasOne", "hasMany",
            "drop", "sync", "get", "clear", "create",
            "exists", "settings", "aggregate"
        ].indexOf(k) >= 0) {
            continue;
        }
        if (typeof Model[k] !== "function" || chain[k]) {
            continue;
        }
        chain[k] = Model[k];
    }
    chain.model = Model;
    chain.options = opts;
    // Make ChainFind thenable - automatically call run() when awaited
    chain.then = function (onFulfilled, onRejected) {
        return chainRun().then(onFulfilled, onRejected);
    };
    chain.catch = function (onRejected) {
        return chainRun().catch(onRejected);
    };
    return chain;
}
function addChainMethod(chain, association, opts) {
    chain[association.hasAccessor] = function (value) {
        if (!opts.exists) {
            opts.exists = [];
        }
        const conditions = {};
        const assocIds = Object.keys(association.mergeAssocId);
        const ids = association.model.id;
        const mergeConditions = (source) => {
            for (let i = 0; i < assocIds.length; i++) {
                if (typeof conditions[assocIds[i]] === "undefined") {
                    conditions[assocIds[i]] = source[ids[i]];
                }
                else if (Array.isArray(conditions[assocIds[i]])) {
                    conditions[assocIds[i]].push(source[ids[i]]);
                }
                else {
                    conditions[assocIds[i]] = [conditions[assocIds[i]], source[ids[i]]];
                }
            }
        };
        if (Array.isArray(value)) {
            for (const v of value) {
                mergeConditions(v);
            }
        }
        else {
            mergeConditions(value);
        }
        opts.exists.push({
            table: association.mergeTable,
            link: [Object.keys(association.mergeId), association.model.id],
            conditions: conditions
        });
        return chain;
    };
}
exports.default = ChainFind;
//# sourceMappingURL=ChainFind.js.map