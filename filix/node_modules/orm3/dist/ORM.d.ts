import enforce from './Validators/index';
import { EventEmitter } from 'events';
import Settings from './Settings';
import Singleton from './Singleton';
import type { Plugin } from './types/Core';
import type { MetadataInspector, MetadataOptions } from './Drivers/DDL/meta';
import type { ORMInterface, ModelOptions, ConnectionOptions, Model as ModelType, ChainRunner, SerialRunner, Instance as OrmInstance, DefineModelFromSchemaOptions, DefineModelsFromSchemaOptions } from './types/Core';
/**
 * @deprecated Use the `enforce` package directly instead
 */
export declare const validators: {
    required: typeof import("./Validators/index").required;
    notEmptyString: typeof import("./Validators/index").notEmptyString;
    rangeNumber: typeof import("./Validators/index").number;
    rangeLength: typeof import("./Validators/index").length;
    insideList: typeof import("./Validators/index").inside;
    outsideList: typeof import("./Validators/index").outside;
    password: typeof import("./Validators/index").password;
    patterns: typeof import("./Validators/enforcements/patterns");
    equalToProperty: any;
    unique: any;
};
export { enforce };
export { Singleton as singleton };
export declare const settings: {
    settings: any;
    set(key: string, value: any): /*elided*/ any;
    get(key: string, def?: any): any;
    unset(...keys: string[]): /*elided*/ any;
};
export { default as Property } from './Property';
export { Settings };
export declare const ErrorCodes: any;
export declare function connect(opts: string | ConnectionOptions): Promise<ORM>;
export declare function use(connection: any, proto: string, opts?: any): Promise<ORM>;
export declare const Text: (data: unknown) => {
    data: unknown;
    type: () => string;
};
export declare function express(...args: any[]): any;
export declare const addAdapter: any;
declare class ORM extends EventEmitter implements ORMInterface {
    validators: any;
    enforce: any;
    settings: any;
    driver_name: string;
    driver: any;
    tools: any;
    models: Record<string, ModelType<any>>;
    plugins: Plugin[];
    customTypes: any;
    constructor(driver_name: string, driver: any, settings: any);
    use(plugin_const: string | Plugin, opts?: any): this;
    define<T = any>(name: string, properties?: Record<string, any>, opts?: ModelOptions<T>): any;
    defineType(name: string, opts: any): this;
    ping(cb?: (err?: Error | null) => void): Promise<void>;
    close(cb?: (err?: Error | null) => void): Promise<void>;
    load(...files: Array<string | string[] | ((err?: Error | null) => void)>): Promise<void>;
    sync(): Promise<void>;
    drop(): Promise<void>;
    getMetadata(options?: MetadataOptions): MetadataInspector;
    defineFromSchema<T = any>(tableName: string, options?: DefineModelFromSchemaOptions<T>): Promise<ModelType<T>>;
    defineAllFromSchema(options?: DefineModelsFromSchemaOptions): Promise<Record<string, ModelType<any>>>;
    /**
     * Execute a set of chain runners sequentially, collecting each result set.
     *
     * The returned runner can be awaited directly or invoked with a callback
     * for legacy consumers. Results are typed according to the provided chain
     * runners, preserving strong typing across chained queries.
     */
    serial<T = OrmInstance>(...chains: ChainRunner<T>[]): SerialRunner<T>;
}
export default ORM;
//# sourceMappingURL=ORM.d.ts.map