"use strict";
/**
 * Hook utility functions - Promise-based
 *
 * All hooks are now promise-based for consistency with async/await patterns.
 * Hooks should return a Promise<void> that resolves when the hook is complete.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.trigger = trigger;
exports.wait = wait;
/**
 * Emit a hook event (for backward compatibility)
 * @deprecated Use await hook() directly instead
 */
function trigger(self, cb, ...args) {
    if (typeof cb === "function") {
        cb.apply(self, args);
    }
}
/**
 * Wait for a hook to complete
 * Hooks should be async functions that return Promise<void>
 *
 * @param self - The context to execute the hook in
 * @param hook - The hook function to execute
 * @param options - Optional arguments to pass to the hook
 * @returns A promise that resolves when the hook completes
 */
async function wait(self, hook, optionsOrCallback, maybeCallback) {
    let options = optionsOrCallback;
    let callback = maybeCallback;
    // Backwards compatibility: if only three args and third is a function,
    // treat it as the callback (Node-style signature).
    if (typeof optionsOrCallback === "function" && maybeCallback === undefined) {
        callback = optionsOrCallback;
        options = undefined;
    }
    if (typeof hook !== "function") {
        if (callback) {
            callback();
        }
        return;
    }
    try {
        const result = options !== undefined
            ? hook.call(self, options)
            : hook.call(self);
        if (result && typeof result.then === "function") {
            await result;
        }
        if (callback) {
            callback();
        }
    }
    catch (error) {
        if (callback) {
            callback(error);
            return;
        }
        throw error;
    }
}
exports.default = { trigger, wait };
//# sourceMappingURL=Hook.js.map