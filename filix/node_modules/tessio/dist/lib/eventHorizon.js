"use strict";
/*
MIT License

Copyright (c) 2019 Rafal Okninski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventHorizon = void 0;
const _ = __importStar(require("lodash"));
const tesseract_1 = require("./tesseract");
const utils_1 = require("./utils");
const backbone_1 = require("./dataModels/backbone");
const UPDATE_REASON_DATA = 'dataUpdate';
const UPDATE_REASON_DATA_RESET = 'dataReset';
/**
 * EventHorizon - Central event management and data orchestration system
 */
class EventHorizon {
    namespace;
    tesseracts;
    sessions;
    constructor(options = {}) {
        this.namespace = options.namespace;
        if (options.commandPort) {
            try {
                // Dynamic import for optional CommandPort
                console.log('CommandPort integration would be implemented here');
            }
            catch (error) {
                console.warn('CommandPort module not available:', error);
            }
        }
        this.tesseracts = new backbone_1.Collection();
        this.sessions = new backbone_1.Collection();
    }
    // Proxy methods to tesseracts collection
    // EventHorizon used to inherit from Collection
    on(...args) {
        return this.tesseracts.on(...args);
    }
    off(...args) {
        return this.tesseracts.off(...args);
    }
    once(...args) {
        return this.tesseracts.once(...args);
    }
    trigger(...args) {
        return this.tesseracts.trigger(...args);
    }
    // Resolve data relationships between tables
    resolve(resolve, data) {
        let result = null;
        if (!resolve.childrenTable) {
            return data[resolve.underlyingField];
        }
        const childrenTableRef = this.tesseracts.get(resolve.childrenTable);
        if (childrenTableRef) {
            const underlyingData = childrenTableRef.getById(String(data[resolve.underlyingField]));
            if (underlyingData) {
                if (underlyingData.removed === true) {
                    return result;
                }
                if (resolve.displayTemplate) {
                    result = _.template.call(underlyingData, resolve.displayTemplate)(underlyingData);
                }
                else {
                    result = underlyingData[resolve.displayField];
                }
            }
            else {
                result = data[resolve.underlyingField];
            }
        }
        return result;
    }
    get(key) {
        const fullName = this.namespace ? `${this.namespace}.${key}` : key;
        return this.tesseracts.get(fullName);
    }
    getTesseract(tableName) {
        return new Promise((resolve) => {
            const tesseract = this.get(tableName);
            if (tesseract) {
                resolve(tesseract);
            }
            else {
                this.on('add', (x) => {
                    if (x.get('id') === tableName) {
                        resolve(x);
                    }
                });
            }
        });
    }
    // Create a new Tesseract instance
    createTesseract(name, options) {
        const tesseract = this.get(name);
        if (tesseract) {
            return tesseract;
        }
        else if (options) {
            const fullName = this.namespace ? `${this.namespace}.${name}` : name;
            const tesseractOptions = {
                ...options,
                id: fullName,
                resolve: this.resolve.bind(this)
            };
            const newTesseract = new tesseract_1.Tesseract(tesseractOptions);
            this.tesseracts.add(newTesseract);
            this.registerTesseract(newTesseract);
            return newTesseract;
        }
        throw new Error(`Tesseract "${name}" not found and no options provided to create it.`);
    }
    registerTesseract(newTesseract) {
        const resolvedColumns = newTesseract.columns.filter((x) => x.resolve);
        resolvedColumns.forEach((column) => {
            const resolveConfig = column.resolve;
            const childrenTable = this.tesseracts.get(resolveConfig.childrenTable);
            if (childrenTable) {
                childrenTable.off('dataUpdate dataRemove');
                childrenTable.on('dataUpdate dataRemove', () => {
                    newTesseract.refreshTesseract && newTesseract.refreshTesseract();
                });
            }
        });
        this.tesseracts.forEach((tesseract) => {
            const resolved = tesseract.columns
                .filter((column) => column.resolve)
                .filter((column) => column.resolve.childrenTable === newTesseract.id);
            if (resolved.length) {
                newTesseract.off('dataUpdate dataRemove');
                newTesseract.on('dataUpdate dataRemove', () => {
                    tesseract.refreshTesseract();
                });
            }
        });
    }
    registerSession(newSession) {
        if (!newSession.config.columns)
            return;
        const columnsWithResolve = newSession.config.columns.filter((x) => x.resolve);
        columnsWithResolve.forEach(column => {
            const resolveConfig = column.resolve;
            if (!resolveConfig.childrenTable) {
                return; // nothing to wire yet
            }
            const childrenTable = this.get(resolveConfig.childrenTable);
            if (childrenTable) {
                childrenTable.off('dataUpdate dataRemove');
                childrenTable.on('dataRemove', (data) => {
                    const updatedIds = data.reduce((acc, x) => {
                        acc[x] = true;
                        return acc;
                    }, {});
                    newSession.updateData(newSession.tesseract.getLinq().where((x) => updatedIds[String(x[resolveConfig.underlyingField])]), false, UPDATE_REASON_DATA);
                });
                childrenTable.on('dataUpdate', (data, _dissableClusterUpdate, updateReason) => {
                    const idProperty = childrenTable.idProperty;
                    const updatedIds = data.reduce((acc, x) => {
                        acc[String(x[idProperty])] = true;
                        return acc;
                    }, {});
                    const arr = newSession.getLinq()
                        .where((x) => updatedIds[String(x[resolveConfig.underlyingField])])
                        .select((x) => x.object)
                        .toArray();
                    newSession.updateData(arr, false, updateReason || UPDATE_REASON_DATA);
                });
            }
        });
    }
    createUnion(name, options) {
        const newTesseract = this.createTesseract(name, options);
        if (!newTesseract) {
            throw new Error(`Failed to create union tesseract: ${name}`);
        }
        if (options.subSessions) {
            _.each(options.subSessions, (sessionQuery) => {
                const session = this.createSession(sessionQuery);
                newTesseract.update(session.getLinq().select((x) => x.object).toArray(), true);
                session.on('dataUpdate', (data) => {
                    if (data.addedIds.length !== 0) {
                        newTesseract.add(data.addedData.map((x) => x.object));
                    }
                    if (data.updatedIds && data.updatedIds.length !== 0) {
                        newTesseract.update(data.updatedData?.map((x) => x.object) || []);
                    }
                    if (data.removedIds.length !== 0) {
                        newTesseract.remove(data.removedIds);
                    }
                }, session);
                newTesseract.on('destroy', () => {
                    session.destroy();
                });
            });
        }
        return newTesseract;
    }
    createTesseractFromSession(name, session) {
        const options = {
            columns: session.getSimpleHeader(),
            clusterSync: false
        };
        let newTesseract = this.get(name);
        if (session.config.groupBy && session.config.groupBy.length !== 0) {
            const firstGroupByIndex = session.config.groupBy[0].dataIndex;
            // Switch primaryKey to GroupBy
            options.columns?.forEach(x => {
                delete x.primaryKey;
                if (x.name === firstGroupByIndex) {
                    x.primaryKey = true;
                }
            });
            let isDirtyCache = false;
            let idsCache = {};
            const mapIds = (a, b) => {
                b.reduce((acc, item) => {
                    acc[item] = true;
                    return acc;
                }, a);
            };
            const clearQueue = (0, utils_1.smartDebounce)(() => {
                if (isDirtyCache) {
                    session.collectGarbage();
                    newTesseract.reset(session.groupData());
                    isDirtyCache = false;
                }
                else {
                    newTesseract.update(session.groupSelectedData(idsCache));
                }
                idsCache = {};
            }, 100);
            if (!newTesseract) {
                newTesseract = this.createTesseract(name, options);
                if (!newTesseract) {
                    throw new Error(`Failed to create tesseract: ${name}`);
                }
                newTesseract.update(session.groupData(), true);
            }
            session.on('dataUpdate', (data) => {
                if (data.addedIds.length !== 0) {
                    mapIds(idsCache, data.addedIds);
                }
                if (data.updatedIds && data.updatedIds.length !== 0) {
                    mapIds(idsCache, data.updatedIds);
                }
                isDirtyCache = data.removedIds.length > 0;
                clearQueue();
            }, session);
        }
        else {
            if (!newTesseract) {
                newTesseract = this.createTesseract(name, options);
                if (!newTesseract) {
                    throw new Error(`Failed to create tesseract: ${name}`);
                }
                newTesseract.update(session.getLinq().select((x) => x.object).toArray(), true);
            }
            session.on('dataUpdate', (data) => {
                if (data.addedIds.length !== 0) {
                    newTesseract.add(data.addedData.map((x) => x.object));
                }
                if (data.updatedIds && data.updatedIds.length !== 0) {
                    newTesseract.update(data.updatedData?.map((x) => x.object) || []);
                }
                if (data.removedIds.length !== 0) {
                    newTesseract.remove(data.removedIds);
                }
            }, session);
        }
        newTesseract.on('destroy', () => {
            session.off();
        });
        return newTesseract;
    }
    createSession(parameters, reuseSession = false) {
        const sessionName = parameters.id || this.generateHash(parameters);
        const table = parameters.table;
        const subSessions = [];
        const tempCaches = [];
        let tesseract;
        const existingSession = this.sessions.get(sessionName);
        if (existingSession) {
            if (!reuseSession) {
                throw new Error(`Session "${sessionName}" already exists.`);
            }
            return existingSession;
        }
        parameters.getTesseract = this.get.bind(this);
        if (typeof table === 'string') {
            tesseract = this.get(table);
        }
        else if (typeof table === 'object') {
            const subSession = this.createSession(table, true);
            subSessions.push(subSession);
            const subSessionId = subSession.get('id');
            tesseract = this.createTesseractFromSession(subSessionId, subSession);
            tempCaches.push(tesseract);
        }
        if (parameters.subSessions) {
            _.each(parameters.subSessions, (item, ref) => {
                const subSession = this.createSession(item, true);
                subSessions.push(subSession);
                const subSessionId = subSession.get('id');
                tempCaches.push(this.createTesseractFromSession(subSessionId, subSession));
                parameters.columns?.forEach((column) => {
                    const resolveConfig = column.resolve;
                    if (resolveConfig && resolveConfig.session === ref) {
                        resolveConfig.childrenTable = subSessionId;
                    }
                });
            });
        }
        if (parameters.columns) {
            parameters.columns.forEach((item) => {
                const resolveConfig = item.resolve;
                if (resolveConfig && typeof resolveConfig.session === 'object') {
                    const subSession = this.createSession(resolveConfig.session, true);
                    subSessions.push(subSession);
                    const subSessionId = subSession.get('id');
                    tempCaches.push(this.createTesseractFromSession(subSessionId, subSession));
                    resolveConfig.childrenTable = subSessionId;
                }
            });
        }
        if (tesseract) {
            parameters.id = parameters.id || sessionName;
            this.sessions.add(tesseract.createSession(parameters));
            const session = this.sessions.get(parameters.id);
            session.on('destroy', () => {
                tempCaches.forEach(x => {
                    if (!x._events.dataUpdate) {
                        x.destroy();
                    }
                });
                subSessions.forEach(x => {
                    if (!x._events.dataUpdate) {
                        x.destroy();
                    }
                });
                this.sessions.remove(session);
            });
            this.registerSession(session);
            return session;
        }
        else {
            throw new Error(`Requested cache "${table}" doesn't exist.`);
        }
    }
    generateHash(obj) {
        // Simple hash implementation as md5.js placeholder
        return JSON.stringify(obj)
            .split('')
            .reduce((a, b) => {
            a = ((a << 5) - a) + b.charCodeAt(0);
            return a & a;
        }, 0)
            .toString(16);
    }
    getSession(sessionName) {
        return this.sessions.get(sessionName);
    }
}
exports.EventHorizon = EventHorizon;
exports.default = EventHorizon;
//# sourceMappingURL=eventHorizon.js.map