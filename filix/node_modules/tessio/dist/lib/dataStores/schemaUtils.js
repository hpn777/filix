"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildBendecSchema = exports.validateColumns = exports.calculateRecordSize = exports.inferByteLength = void 0;
const BYTES_PER_CHAR = 2; // conservative default for UTF-16 style storage
const NUMERIC_BYTE_LENGTH = {
    int8: 1,
    uint8: 1,
    int16: 2,
    uint16: 2,
    int32: 4,
    uint32: 4,
    int64: 8,
    uint64: 8,
    float32: 4,
    float64: 8,
    boolean: 1,
    string: 0,
    json: 0,
};
function inferByteLength(column) {
    const columnType = column.columnType;
    if (!columnType) {
        return 0;
    }
    if (columnType === 'string') {
        const maxChars = column.storage?.maxChars ?? 0;
        return maxChars > 0 ? maxChars * 2 : 0;
    }
    if (columnType === 'json') {
        return column.storage?.byteLength ?? 0;
    }
    return NUMERIC_BYTE_LENGTH[columnType] ?? 0;
}
exports.inferByteLength = inferByteLength;
function calculateRecordSize(columns) {
    return columns.reduce((size, column) => size + inferByteLength(column), 0);
}
exports.calculateRecordSize = calculateRecordSize;
function validateColumns(columns) {
    columns.forEach(column => {
        if (column.columnType === 'string') {
            if (!column.storage || !column.storage.maxChars) {
                throw new Error(`Column "${column.name}" requires storage.maxChars for shared-memory mode.`);
            }
        }
        if (column.columnType === 'json') {
            if (!column.storage || !column.storage.byteLength) {
                throw new Error(`Column "${column.name}" requires storage.byteLength for json type in shared-memory mode.`);
            }
        }
    });
}
exports.validateColumns = validateColumns;
const PRIMITIVE_TYPE_DEFINITIONS = {
    bool: { name: 'bool', size: 1 },
    u8: { name: 'u8', size: 1 },
    u16: { name: 'u16', size: 2 },
    u32: { name: 'u32', size: 4 },
    u64: { name: 'u64', size: 8 },
    i64: { name: 'i64', size: 8 },
    f64: { name: 'f64', size: 8 },
};
function buildBendecSchema(columns) {
    const fields = [];
    const primitiveDependencies = new Set();
    for (const column of columns) {
        const definition = mapColumnToBendecField(column, primitiveDependencies);
        if (!definition) {
            return null;
        }
        fields.push({ name: column.name, ...definition });
    }
    const primitives = Array.from(primitiveDependencies)
        .map(typeName => PRIMITIVE_TYPE_DEFINITIONS[typeName])
        .filter((definition) => !!definition);
    if (primitives.length !== primitiveDependencies.size) {
        return null;
    }
    return {
        typeName: 'TesseractRow',
        types: [
            ...primitives,
            {
                name: 'TesseractRow',
                fields,
            },
        ],
    };
}
exports.buildBendecSchema = buildBendecSchema;
function mapColumnToBendecField(column, primitiveDependencies) {
    const binaryType = column.columnType;
    switch (binaryType) {
        case 'boolean':
            primitiveDependencies.add('bool');
            return { type: 'bool' };
        case 'uint8':
            primitiveDependencies.add('u8');
            return { type: 'u8' };
        case 'uint16':
            primitiveDependencies.add('u16');
            return { type: 'u16' };
        case 'uint32':
            primitiveDependencies.add('u32');
            return { type: 'u32' };
        case 'uint64':
            primitiveDependencies.add('u64');
            return { type: 'u64' };
        case 'int64':
            primitiveDependencies.add('i64');
            return { type: 'i64' };
        case 'float64':
            primitiveDependencies.add('f64');
            return { type: 'f64' };
        case 'string':
        case 'json':
            return null;
        default:
            return null;
    }
}
//# sourceMappingURL=schemaUtils.js.map