"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferDataStore = void 0;
const schemaUtils_1 = require("./schemaUtils");
const rowSymbols_1 = require("./rowSymbols");
class BufferDataStore {
    columns = [];
    primaryKeyName;
    recordSizeHint = 0;
    dataCache = [];
    rows = [];
    rowIndex = new Map();
    dataMap = new Map();
    bendecInstance = null;
    bendecTypeName;
    bendecFrameSize;
    bendecEncodeTakesTarget = false;
    bendecWrapAvailable = false;
    bendecDecodeAvailable = false;
    encodeMode = 0 /* EncodeMode.Json */;
    constructor(columns, initialCapacity) {
        this.init(columns, initialCapacity);
    }
    init(columns, initialCapacity) {
        this.columns = columns.slice();
        this.primaryKeyName = columns.find(col => col.primaryKey)?.name ?? columns[0]?.name;
        this.recordSizeHint = (0, schemaUtils_1.calculateRecordSize)(columns);
        this.dataCache = [];
        this.rows = [];
        this.rowIndex.clear();
        this.dataMap.clear();
        this.resetBendecState();
        this.initialiseBendec(columns);
        if (initialCapacity && initialCapacity > 0) {
            this.reserve(initialCapacity);
        }
    }
    get length() {
        return this.rows.length;
    }
    allocate(initialData) {
        const buffer = this.createBackingBuffer();
        const row = this.wrapBuffer(buffer);
        this.attachRowMetadata(row, buffer, this.rows.length);
        row.removed = false;
        if (initialData) {
            Object.assign(row, initialData);
        }
        this.rows.push(row);
        this.dataCache.push(buffer);
        this.rowIndex.set(row, this.rows.length - 1);
        return row;
    }
    commit(row, idOverride) {
        const index = this.ensureRowIndex(row);
        const id = idOverride ?? this.extractPrimaryKey(row);
        if (id === undefined || id === null) {
            throw new Error('BufferDataStore.commit: row is missing primary key value');
        }
        const buffer = this.ensureRowBuffer(row, index);
        this.dataCache[index] = buffer;
        this.rows[index] = row;
        this.dataMap.set(id, index);
        return row;
    }
    append(row) {
        return this.commit(row);
    }
    write(index, row) {
        if (index < 0 || index >= this.rows.length) {
            return this.append(row);
        }
        const previousRow = this.rows[index];
        if (previousRow && previousRow !== row) {
            const previousId = this.extractPrimaryKey(previousRow);
            if (previousId !== undefined) {
                this.dataMap.delete(previousId);
            }
            this.rowIndex.delete(previousRow);
        }
        this.rows[index] = row;
        this.rowIndex.set(row, index);
        const buffer = this.ensureRowBuffer(row, index);
        this.dataCache[index] = buffer;
        const id = this.extractPrimaryKey(row);
        if (id !== undefined) {
            this.dataMap.set(id, index);
        }
        return row;
    }
    read(index) {
        return this.rows[index];
    }
    remove(index) {
        if (index < 0 || index >= this.rows.length) {
            return;
        }
        const [removedRow] = this.rows.splice(index, 1);
        this.dataCache.splice(index, 1);
        if (removedRow) {
            const removedId = this.extractPrimaryKey(removedRow);
            if (removedId !== undefined) {
                this.dataMap.delete(removedId);
            }
            removedRow.removed = true;
            this.rowIndex.delete(removedRow);
        }
        this.reindexFrom(index);
    }
    removeRow(row) {
        const index = this.rowIndex.get(row);
        if (index !== undefined) {
            this.remove(index);
            return;
        }
        const id = this.extractPrimaryKey(row);
        if (id === undefined) {
            return;
        }
        const mappedIndex = this.dataMap.get(id);
        if (mappedIndex !== undefined) {
            this.remove(mappedIndex);
        }
    }
    refreshRow(row) {
        const index = this.ensureRowIndex(row);
        const buffer = this.ensureRowBuffer(row, index);
        this.dataCache[index] = buffer;
        this.rows[index] = row;
        const id = this.extractPrimaryKey(row);
        if (id !== undefined) {
            this.dataMap.set(id, index);
        }
    }
    forEach(callback) {
        for (let i = 0; i < this.rows.length; i++) {
            const row = this.rows[i];
            if (!row) {
                continue;
            }
            callback(row, i);
        }
    }
    materialize(indices) {
        if (!indices) {
            return this.rows.filter((row) => !!row);
        }
        return indices
            .map(index => this.rows[index])
            .filter((row) => !!row);
    }
    getById(id) {
        const index = this.dataMap.get(id);
        if (index === undefined) {
            return undefined;
        }
        return this.rows[index];
    }
    getBuffer(index) {
        return this.dataCache[index];
    }
    getRowBuffer(row) {
        const index = this.rowIndex.get(row);
        if (index === undefined) {
            return row[rowSymbols_1.ROW_BUFFER_SYMBOL];
        }
        return this.dataCache[index];
    }
    wrap(index) {
        if (!this.hasActiveBendec()) {
            return undefined;
        }
        const buffer = this.dataCache[index];
        if (!buffer) {
            return undefined;
        }
        return this.attachRowMetadata(this.bendecInstance.wrap(this.bendecTypeName, buffer), buffer, index);
    }
    wrapRow(row) {
        const index = this.rowIndex.get(row);
        if (index === undefined) {
            return undefined;
        }
        return this.wrap(index);
    }
    wrapById(id) {
        const index = this.dataMap.get(id);
        if (index === undefined) {
            return undefined;
        }
        return this.wrap(index);
    }
    decodeBuffer(buffer) {
        if (this.encodeMode === 1 /* EncodeMode.Bendec */ && this.hasActiveBendec()) {
            if (this.bendecDecodeAvailable) {
                const decoded = this.bendecInstance.decodeAs(buffer, this.bendecTypeName);
                return this.attachRowMetadata(decoded, buffer);
            }
            const view = this.bendecInstance.wrap(this.bendecTypeName, buffer);
            const row = {};
            for (const column of this.columns) {
                row[column.name] = view[column.name];
            }
            return this.attachRowMetadata(row, buffer);
        }
        if (!buffer.length) {
            return this.attachRowMetadata({});
        }
        const parsed = JSON.parse(buffer.toString('utf8'));
        return this.attachRowMetadata(parsed);
    }
    get buffersView() {
        return this.dataCache.slice();
    }
    clear() {
        this.dataCache = [];
        this.rows = [];
        this.rowIndex.clear();
        this.dataMap.clear();
    }
    destroy() {
        this.clear();
        this.resetBendecState();
    }
    reserve(_capacity) {
        // Dynamic arrays grow on demand; reserve kept for API completeness.
    }
    createBackingBuffer() {
        if (this.encodeMode === 1 /* EncodeMode.Bendec */ && this.hasActiveBendec()) {
            const frameSize = this.bendecFrameSize ?? this.recordSizeHint ?? 0;
            const size = frameSize > 0 ? frameSize : 256;
            return Buffer.alloc(size);
        }
        return Buffer.alloc(0);
    }
    wrapBuffer(buffer) {
        if (this.encodeMode === 1 /* EncodeMode.Bendec */ && this.hasActiveBendec() && buffer.length) {
            return this.bendecInstance.wrap(this.bendecTypeName, buffer);
        }
        return {};
    }
    ensureRowIndex(row) {
        let index = this.rowIndex.get(row);
        if (index !== undefined) {
            return index;
        }
        const buffer = this.getRowBuffer(row) ?? this.createBackingBuffer();
        this.rows.push(row);
        this.dataCache.push(buffer);
        index = this.rows.length - 1;
        this.rowIndex.set(row, index);
        this.attachRowMetadata(row, buffer, index);
        return index;
    }
    ensureRowBuffer(row, index) {
        const buffer = this.encodeRow(row, index);
        this.dataCache[index] = buffer;
        return buffer;
    }
    attachRowMetadata(row, buffer, index) {
        if (!row || typeof row !== 'object') {
            return row;
        }
        if (buffer !== undefined) {
            Object.defineProperty(row, rowSymbols_1.ROW_BUFFER_SYMBOL, {
                value: buffer,
                enumerable: false,
                configurable: true,
            });
        }
        else if (!Object.prototype.hasOwnProperty.call(row, rowSymbols_1.ROW_BUFFER_SYMBOL)) {
            Object.defineProperty(row, rowSymbols_1.ROW_BUFFER_SYMBOL, {
                value: null,
                enumerable: false,
                configurable: true,
            });
        }
        if (index !== undefined) {
            Object.defineProperty(row, rowSymbols_1.ROW_INDEX_SYMBOL, {
                value: index,
                enumerable: false,
                configurable: true,
            });
        }
        if (!Object.prototype.hasOwnProperty.call(row, rowSymbols_1.ROW_MARKER_SYMBOL)) {
            Object.defineProperty(row, rowSymbols_1.ROW_MARKER_SYMBOL, {
                value: true,
                enumerable: false,
            });
        }
        if (!Object.prototype.hasOwnProperty.call(row, 'removed')) {
            Object.defineProperty(row, 'removed', {
                value: false,
                writable: true,
                enumerable: true,
                configurable: true,
            });
        }
        return row;
    }
    extractPrimaryKey(row) {
        if (!this.primaryKeyName) {
            return undefined;
        }
        return row[this.primaryKeyName];
    }
    resetBendecState() {
        this.bendecInstance = null;
        this.bendecTypeName = undefined;
        this.bendecFrameSize = undefined;
        this.bendecEncodeTakesTarget = false;
        this.bendecWrapAvailable = false;
        this.bendecDecodeAvailable = false;
        this.encodeMode = 0 /* EncodeMode.Json */;
    }
    initialiseBendec(columns) {
        const BendecModule = this.loadBendec();
        if (!BendecModule) {
            return;
        }
        try {
            (0, schemaUtils_1.validateColumns)(columns);
            const schema = (0, schemaUtils_1.buildBendecSchema)(columns);
            if (!schema) {
                return;
            }
            const instance = this.createBendecInstance(BendecModule, schema);
            if (!instance) {
                return;
            }
            if (typeof instance.addTypes === 'function') {
                instance.addTypes(schema.types);
            }
            else if (typeof instance.registerTypes === 'function') {
                instance.registerTypes(schema.types);
            }
            else if (typeof instance.loadSchema === 'function') {
                instance.loadSchema(schema);
            }
            else if (typeof instance.loadTypes === 'function') {
                instance.loadTypes(schema.types);
            }
            this.bendecInstance = instance;
            this.bendecTypeName = schema.typeName;
            this.bendecFrameSize = this.resolveBendecFrameSize(instance, schema.typeName);
            this.bendecEncodeTakesTarget = typeof instance.encodeAs === 'function' && instance.encodeAs.length >= 3;
            this.bendecWrapAvailable = typeof instance.wrap === 'function';
            this.bendecDecodeAvailable = typeof instance.decodeAs === 'function';
            this.encodeMode = 1 /* EncodeMode.Bendec */;
        }
        catch (error) {
            console.warn('BufferDataStore: Bendec initialisation failed, using JSON encoding instead.', error);
            this.resetBendecState();
        }
    }
    hasActiveBendec() {
        return !!(this.bendecInstance && this.bendecTypeName);
    }
    resolveBendecFrameSize(instance, typeName) {
        if (instance && typeof instance.getSize === 'function') {
            const size = instance.getSize(typeName);
            const numeric = typeof size === 'bigint' ? Number(size) : Number(size);
            if (Number.isFinite(numeric) && numeric > 0) {
                return numeric;
            }
        }
        if (this.recordSizeHint > 0) {
            return this.recordSizeHint;
        }
        return undefined;
    }
    createBendecInstance(BendecModule, schema) {
        const tryCreate = (factory, args) => {
            if (typeof factory !== 'function') {
                return null;
            }
            try {
                return factory(...args);
            }
            catch (error) {
                return null;
            }
        };
        const direct = tryCreate(BendecModule?.createBendec, [schema])
            || tryCreate(BendecModule?.createBendec, [schema.types])
            || tryCreate(BendecModule?.createBendec, []);
        if (direct) {
            return direct;
        }
        const message = tryCreate(BendecModule?.createMessageBendec, [schema])
            || tryCreate(BendecModule?.createMessageBendec, [schema.types])
            || tryCreate(BendecModule?.createMessageBendec, []);
        if (message) {
            return message;
        }
        const Ctor = BendecModule?.Bendec ?? BendecModule;
        if (typeof Ctor === 'function') {
            try {
                return new Ctor();
            }
            catch (error) {
                return null;
            }
        }
        return null;
    }
    loadBendec() {
        try {
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const bendecModule = require('bendec');
            return bendecModule?.default ?? bendecModule;
        }
        catch (error) {
            return null;
        }
    }
    reindexFrom(start) {
        for (let i = start; i < this.rows.length; i++) {
            const row = this.rows[i];
            if (!row) {
                continue;
            }
            this.rowIndex.set(row, i);
            this.attachRowMetadata(row, this.dataCache[i], i);
            const id = this.extractPrimaryKey(row);
            if (id !== undefined) {
                this.dataMap.set(id, i);
            }
        }
    }
    encodeRow(row, index) {
        if (this.encodeMode === 1 /* EncodeMode.Bendec */ && this.hasActiveBendec()) {
            const existing = row[rowSymbols_1.ROW_BUFFER_SYMBOL];
            if (this.bendecEncodeTakesTarget) {
                const target = existing && existing.length >= (this.bendecFrameSize ?? 0)
                    ? existing
                    : Buffer.alloc(this.bendecFrameSize ?? this.recordSizeHint ?? 256);
                const result = this.bendecInstance.encodeAs(row, this.bendecTypeName, target);
                const used = typeof result === 'number' && result > 0 && result <= target.length
                    ? result
                    : target.length;
                const output = used === target.length ? target : target.subarray(0, used);
                this.attachRowMetadata(row, output, index);
                return output;
            }
            const encoded = this.bendecInstance.encodeAs(row, this.bendecTypeName);
            const output = Buffer.isBuffer(encoded) ? encoded : Buffer.from(encoded);
            this.attachRowMetadata(row, output, index);
            return output;
        }
        const payload = Buffer.from(JSON.stringify(row), 'utf8');
        this.attachRowMetadata(row, payload, index);
        return payload;
    }
}
exports.BufferDataStore = BufferDataStore;
//# sourceMappingURL=bufferDataStore.js.map