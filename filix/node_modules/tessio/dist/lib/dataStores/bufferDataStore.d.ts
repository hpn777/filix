/// <reference types="node" />
/// <reference types="node" />
import { ColumnDef, DataRow, IDataStore, IdValue } from '../../types';
export declare class BufferDataStore implements IDataStore {
    private columns;
    private primaryKeyName?;
    private recordSizeHint;
    private dataCache;
    private rows;
    private rowIndex;
    private dataMap;
    private bendecInstance;
    private bendecTypeName?;
    private bendecFrameSize?;
    private bendecEncodeTakesTarget;
    private bendecWrapAvailable;
    private bendecDecodeAvailable;
    private encodeMode;
    constructor(columns: ColumnDef[], initialCapacity?: number);
    init(columns: ColumnDef[], initialCapacity?: number): void;
    get length(): number;
    allocate(initialData?: Partial<DataRow>): DataRow;
    commit(row: DataRow, idOverride?: IdValue): DataRow;
    append(row: DataRow): DataRow;
    write(index: number, row: DataRow): DataRow;
    read(index: number): DataRow | undefined;
    remove(index: number): void;
    removeRow(row: DataRow): void;
    refreshRow(row: DataRow): void;
    forEach(callback: (row: DataRow, index: number) => void): void;
    materialize(indices?: number[]): DataRow[];
    getById(id: IdValue): DataRow | undefined;
    getBuffer(index: number): Buffer | undefined;
    getRowBuffer(row: DataRow): Buffer | undefined;
    wrap(index: number): any | undefined;
    wrapRow(row: DataRow): any | undefined;
    wrapById(id: IdValue): any | undefined;
    decodeBuffer(buffer: Buffer): DataRow;
    get buffersView(): readonly Buffer[];
    clear(): void;
    destroy(): void;
    private reserve;
    private createBackingBuffer;
    private wrapBuffer;
    private ensureRowIndex;
    private ensureRowBuffer;
    private attachRowMetadata;
    private extractPrimaryKey;
    private resetBendecState;
    private initialiseBendec;
    private hasActiveBendec;
    private resolveBendecFrameSize;
    private createBendecInstance;
    private loadBendec;
    private reindexFrom;
    private encodeRow;
}
