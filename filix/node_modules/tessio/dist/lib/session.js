"use strict";
/*
MIT License

Copyright (c) 2019 Rafal Okninski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UPDATE_REASON_COLUMNS_CHANGED = exports.UPDATE_REASON_DATA = exports.Session = void 0;
const backbone_1 = require("./dataModels/backbone");
const filters_1 = require("./filters");
const filter_1 = require("./filter");
const linq = __importStar(require("linq"));
const utils_1 = require("./utils");
const UPDATE_REASON_DATA = 'dataUpdate';
exports.UPDATE_REASON_DATA = UPDATE_REASON_DATA;
// const UPDATE_REASON_DATA_RESET = 'dataReset'; // unused
const UPDATE_REASON_COLUMNS_CHANGED = 'columnsChanged';
exports.UPDATE_REASON_COLUMNS_CHANGED = UPDATE_REASON_COLUMNS_CHANGED;
class Session extends backbone_1.Model {
    filters;
    isLive = true;
    tesseract;
    getTesseract;
    config;
    columns;
    defaultObjDef;
    dataWrapper;
    requireFiltring = false;
    hasGarbage = true;
    idProperty;
    idIndex;
    permanentFilter;
    dataCache = [];
    dataMap = {};
    requireSorting = false;
    requireDataReset = false;
    constructor(model, _options) {
        super(model);
        this.filters = new filters_1.Filters();
        this.isLive = true;
        // TODO: move this to constructor arguments
        this.tesseract = this.get('tesseract');
        this.getTesseract = this.get('getTesseract');
        this.config = this.get('config');
        const tesseractHeader = this.tesseract.getSimpleHeader();
        this.columns = this.config.columns || tesseractHeader;
        // generating proxy config
        const allColumns = (0, utils_1.mergeColumns)(tesseractHeader, this.columns);
        this.defaultObjDef = (0, utils_1.createSessionProxyConfig)(this.getTesseract, allColumns, this.columns);
        this.dataWrapper = new this.defaultObjDef();
        //---------------------
        this.requireFiltring = false;
        this.hasGarbage = true;
        //session primary key
        this.idProperty = this.tesseract.idProperty;
        this.idIndex = this.tesseract.idIndex;
        if (this.config.columns !== undefined) {
            const idColumn = this.columns.find((x) => x.primaryKey);
            if (idColumn) {
                this.idProperty = idColumn.name;
            }
            this.idIndex = this.columns.findIndex((x) => x.name === this.idProperty);
        }
        //-------------------
        this.permanentFilter = this.config.permanentFilter;
        this.refresh();
        this.tesseract.on('dataUpdate', (data, disableClusterUpdate, reason = UPDATE_REASON_DATA) => {
            this.updateData(data, disableClusterUpdate, reason);
        }, this);
        this.tesseract.on('dataRemove', (data, disableClusterUpdate) => {
            this.removeData(data, disableClusterUpdate);
        }, this);
        this.on('destroy', () => {
            this.tesseract.off(null, null, this);
        });
    }
    refresh() {
        let query = linq.from(this.tesseract.getData());
        const idProperty = this.idProperty;
        if (this.columns) {
            query = query.select((x) => this.dataWrapper.setData(x));
        }
        if (this.hasGarbage || this.config.filter || this.config.permanentFilter) {
            const tempFilter = this.config.filter || [];
            const tempPermanentFilter = this.config.permanentFilter || [];
            this.config.filter = tempPermanentFilter.concat(tempFilter);
            this.filters.reset(this.config.filter.map((f) => new filter_1.Filter(f)));
            query = query.where((x) => this.filters.applyFilters(x))
                .select((x) => x.raw);
            this.requireFiltring = false;
            this.hasGarbage = false;
        }
        if (this.config.sort) {
            this.dataCache = (0, utils_1.applyOrder)(this.config.sort, query.toArray(), this.defaultObjDef);
            query = linq.from(this.dataCache);
            this.requireSorting = false;
        }
        this.dataCache = query.toArray();
        this.dataMap = query.aggregate({}, (acc, item) => {
            acc[item[idProperty]] = item;
            return acc;
        });
    }
    updateData(data, disableClusterUpdate, updateReason) {
        const filters = this.filters;
        const addedRows = [];
        const updatedRows = [];
        const removedRows = [];
        const addedIds = [];
        const updatedIds = [];
        const removedIds = [];
        const idProperty = this.idProperty;
        if (filters.length) {
            data.forEach((item) => {
                const tempId = item[idProperty];
                const sessionItem = this.dataWrapper.setData(item);
                if (filters.applyFilters(sessionItem)) {
                    if (this.dataMap[tempId]) {
                        updatedRows.push(this.dataMap[tempId]);
                        updatedIds.push(tempId);
                    }
                    else {
                        this.dataCache.push(item);
                        this.dataMap[tempId] = item;
                        addedRows.push(item);
                        addedIds.push(tempId);
                    }
                }
                else {
                    if (this.dataMap[tempId]) {
                        removedIds.push(tempId);
                        removedRows.push(this.dataMap[tempId]);
                        delete this.dataMap[tempId];
                        this.requireFiltring = true;
                    }
                }
            });
            if (addedIds.length || updatedIds.length || removedIds.length) {
                this.requireSorting = true;
            }
        }
        else {
            data.forEach((item) => {
                const tempId = item[idProperty];
                if (this.dataMap[tempId]) {
                    updatedRows.push(item);
                    updatedIds.push(tempId);
                }
                else {
                    this.dataCache.push(item);
                    this.dataMap[tempId] = item;
                    addedRows.push(item);
                    addedIds.push(tempId);
                }
            });
            this.requireSorting = true;
        }
        const addedData = linq.from(addedRows).select((x) => this.dataWrapper.setData(x));
        const updatedData = linq.from(updatedRows).select((x) => this.dataWrapper.setData(x));
        const removedData = linq.from(removedRows).select((x) => this.dataWrapper.setData(x));
        const result = {
            addedIds: addedIds,
            addedData: addedData,
            updatedIds: updatedIds,
            updatedData: updatedData,
            updateReason: updateReason,
            removedIds: removedIds,
            removedData: removedData,
            toJSON: () => {
                return {
                    addedIds: addedIds,
                    addedData: addedData.select((x) => x.object).toArray(),
                    updatedIds: updatedIds,
                    updatedData: updatedData.select((x) => x.object).toArray(),
                    updateReason: updateReason,
                    removedIds: removedIds,
                    removedData: removedData.select((x) => x.object).toArray(),
                };
            }
        };
        if (addedIds.length || updatedRows.length || removedRows.length) {
            this.trigger('dataUpdate', result, disableClusterUpdate);
        }
        return result;
    }
    removeData(data, disableClusterUpdate) {
        const removedIds = [];
        const removedRows = [];
        data.forEach((item) => {
            if (this.dataMap[item]) {
                removedIds.push(item);
                removedRows.push(this.dataMap[item]);
                delete this.dataMap[item];
            }
        });
        const removedData = linq.from(removedRows).select((x) => this.dataWrapper.setData(x));
        const result = {
            addedIds: [],
            addedData: linq.from([]),
            updatedIds: [],
            updatedData: linq.from([]),
            removedIds: removedIds,
            removedData: removedData,
            toJSON: () => {
                return {
                    addedIds: [],
                    addedData: [],
                    updatedIds: [],
                    updatedData: [],
                    removedIds: removedIds,
                    removedData: removedData.select((x) => x.object).toArray()
                };
            }
        };
        if (removedRows.length) {
            this.requireFiltring = true;
            this.trigger('dataUpdate', result, disableClusterUpdate);
        }
        return result;
    }
    clearSession() {
        this.dataCache = [];
        this.dataMap = {};
        this.requireDataReset = true;
    }
    _getData(request) {
        const config = this.config;
        if (this.requireDataReset) {
            this.dataCache = this.tesseract.getData();
            this.requireDataReset = false;
        }
        if (request) {
            config.requestId = request.requestId;
            config.page = request.page;
            if (request.sort && JSON.stringify(config.sort) !== JSON.stringify(request.sort)) {
                config.sort = request.sort;
                this.requireSorting = true;
            }
            if (Array.isArray(request.filter)) {
                if (this.permanentFilter && this.permanentFilter.length) {
                    request.filter = this.permanentFilter.concat(request.filter);
                }
                if (JSON.stringify(config.filter) !== JSON.stringify(request.filter)) {
                    config.filter = request.filter;
                    this.filters.reset(request.filter.map((f) => new filter_1.Filter(f)));
                    this.requireFiltring = true;
                    this.requireSorting = true;
                }
            }
            config.start = request.start;
            config.limit = request.limit;
        }
        if (this.requireFiltring || this.requireSorting || config.start || config.limit) {
            let query = linq.from(this.dataCache);
            if (this.requireFiltring) {
                query = this.collectGarbage();
            }
            if (this.requireSorting && config.sort) {
                this.dataCache = (0, utils_1.applyOrder)(config.sort, this.dataCache, this.defaultObjDef);
                query = linq.from(this.dataCache);
            }
            this.requireSorting = this.requireFiltring = false;
            if (config.start) {
                query = query.skip(config.start);
            }
            if (config.limit) {
                query = query.take(config.limit);
            }
            return query;
        }
        else {
            return linq.from(this.dataCache);
        }
    }
    getData(request) {
        return this._getData(request).toArray();
    }
    getById(id) {
        return this.dataWrapper.setData(this.dataMap[id]);
    }
    getLinq(request) {
        return this._getData(request).select((x) => this.dataWrapper.setData(x));
    }
    getCount() {
        if (this.requireFiltring) {
            this.collectGarbage();
        }
        return this.dataCache.length;
    }
    collectGarbage() {
        const indexedFilter = linq.from(this.config.filter)
            .firstOrDefault((x) => x !== undefined &&
            x.field !== undefined &&
            this.tesseract.secondaryIndexes.indexOf(x.field) !== -1 &&
            (x.comparison === 'eq' || x.comparison === '=='));
        let query;
        if (indexedFilter && indexedFilter.field) {
            query = linq.from(this.tesseract.dataIndex[indexedFilter.field][indexedFilter.value]);
        }
        else {
            query = linq.from(this.tesseract.getData());
        }
        query = query
            .select((x) => this.dataWrapper.setData(x))
            .where((x) => this.filters.applyFilters(x))
            .select((x) => x.raw);
        this.requireFiltring = false;
        this.hasGarbage = false;
        this.dataCache = [];
        this.dataMap = query.aggregate({}, (acc, item) => {
            this.dataCache.push(item);
            acc[item[this.idProperty]] = item;
            return acc;
        });
        return linq.from(this.dataCache);
    }
    filterData(filtersAttr) {
        const config = this.config;
        if (filtersAttr) {
            if (this.permanentFilter) {
                config.filter = this.permanentFilter.concat(filtersAttr);
            }
            else {
                config.filter = filtersAttr;
            }
            this.filters.reset(config.filter.map((f) => new filter_1.Filter(f)));
            this.requireFiltring = true;
            this.requireSorting = true;
        }
    }
    groupData(groupBy, includeLeafs, nodeId) {
        const config = this.config;
        if (groupBy) {
            config.groupBy = groupBy;
        }
        const dataCache = this.getData();
        if (dataCache.length) {
            return (0, utils_1.groupData)(this.columns, dataCache, this.dataWrapper, config.groupBy, includeLeafs !== undefined ? includeLeafs : config.includeLeafs, '', [], {}, nodeId || this.tesseract.idProperty);
        }
        else {
            return [];
        }
    }
    groupSelectedData(selectedRowsIds, groupBy, includeLeafs, nodeId) {
        const config = this.config;
        if (groupBy) {
            config.groupBy = groupBy;
        }
        return (0, utils_1.groupSelectedData)(this.columns, this.getData(), this.dataWrapper, config.groupBy, selectedRowsIds, includeLeafs !== undefined ? includeLeafs : config.includeLeafs, '', [], {}, nodeId || this.tesseract.idProperty, this.filters.items || []);
    }
    returnTree(rootIdValue, parentIdField, groups) {
        const root = this.dataMap[rootIdValue];
        if (root) {
            if (!groups) {
                groups = this.getLinq()
                    .select((x) => x.object)
                    .groupBy((x) => x[parentIdField]);
            }
            const newItem = this.dataWrapper.setData(root).object;
            const subGroup = groups.firstOrDefault((x) => x.key() === rootIdValue, 0);
            if (subGroup) {
                newItem.children = [];
                subGroup
                    .forEach((x) => {
                    if (x[this.idProperty] !== rootIdValue) {
                        const childrenItem = this.returnTree(x[this.idProperty], parentIdField, groups);
                        newItem.children.push(childrenItem);
                    }
                });
            }
            newItem.leaf = !newItem.children;
            return newItem;
        }
    }
    updateColumns(updatedColumns) {
        if (updatedColumns.findIndex((x) => x.name === 'removed')) {
            updatedColumns.push({
                name: 'removed',
                columnType: 'bool'
            });
        }
        this.columns = updatedColumns;
        const allColumns = (0, utils_1.mergeColumns)(this.tesseract.columns, this.columns);
        this.defaultObjDef = (0, utils_1.createSessionProxyConfig)(this.getTesseract, allColumns, this.columns);
        this.dataWrapper = new this.defaultObjDef();
        this.updateData(this.collectGarbage().toArray(), false, UPDATE_REASON_COLUMNS_CHANGED);
    }
    getHeader(excludeHiddenColumns) {
        return (0, utils_1.getHeader)(this.columns || this.tesseract, excludeHiddenColumns);
    }
    getSimpleHeader(excludeHiddenColumns) {
        return (0, utils_1.getSimpleHeader)(this.columns || this.tesseract, excludeHiddenColumns);
    }
}
exports.Session = Session;
//# sourceMappingURL=session.js.map