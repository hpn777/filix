"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSharedMemorySchema = void 0;
const numericTypeMap = {
    int8: { bendecType: 'i8', defaultValue: 0 },
    uint8: { bendecType: 'u8', defaultValue: 0 },
    int16: { bendecType: 'i16', defaultValue: 0 },
    uint16: { bendecType: 'u16', defaultValue: 0 },
    int32: { bendecType: 'i32', defaultValue: 0 },
    uint32: { bendecType: 'u32', defaultValue: 0 },
    int64: { bendecType: 'i64', defaultValue: BigInt(0) },
    uint64: { bendecType: 'u64', defaultValue: BigInt(0) },
    float32: { bendecType: 'f32', defaultValue: 0 },
    float64: { bendecType: 'f64', defaultValue: 0 },
};
const primitiveDefinitions = [
    { name: 'u8', size: 1 },
    { name: 'i8', size: 1 },
    { name: 'u16', size: 2 },
    { name: 'i16', size: 2 },
    { name: 'u32', size: 4 },
    { name: 'i32', size: 4 },
    { name: 'u64', size: 8 },
    { name: 'i64', size: 8 },
    { name: 'f32', size: 4 },
    { name: 'f64', size: 8 },
    { name: 'char', size: 1 },
];
function resolveStorageType(column) {
    const candidate = column.columnType;
    if (candidate && candidate in numericTypeMap) {
        return candidate;
    }
    switch (column.columnType) {
        case 'boolean':
            return 'boolean';
        case 'string':
        case 'text':
        case 'dimension':
        case 'enum':
            return 'string';
        case 'metric':
        case 'number':
            return 'float64';
        case 'date':
            return 'int64';
        default:
            return 'string';
    }
}
function normalizeColumn(column) {
    const storageType = resolveStorageType(column);
    const nullable = Boolean(column.storage?.nullable);
    const nullFlagKey = `__${column.name}_null`;
    if (storageType === 'string') {
        const maxChars = column.storage?.maxChars ?? 256;
        const bendecField = {
            name: column.name,
            type: 'char',
            length: maxChars,
        };
        return {
            name: column.name,
            storageType,
            nullable,
            nullFlagKey,
            defaultValue: Buffer.alloc(maxChars),
            bendecField,
            transform: {
                encode: (value) => {
                    if (value === undefined || value === null) {
                        return Buffer.alloc(maxChars);
                    }
                    const stringValue = column.storage?.codec === 'json' ? JSON.stringify(value) : String(value);
                    const buffer = Buffer.alloc(maxChars);
                    buffer.write(stringValue.slice(0, maxChars), 0, 'utf8');
                    return buffer;
                },
                decode: (value) => {
                    const raw = value.toString('utf8').replace(/\0+$/, '');
                    if (column.storage?.codec === 'json') {
                        if (!raw)
                            return null;
                        try {
                            return JSON.parse(raw);
                        }
                        catch (err) {
                            return raw;
                        }
                    }
                    return raw;
                },
            },
        };
    }
    if (storageType === 'boolean') {
        const bendecField = { name: column.name, type: 'u8' };
        return {
            name: column.name,
            storageType,
            nullable,
            nullFlagKey,
            defaultValue: 0,
            bendecField,
            transform: {
                encode: (value) => (value ? 1 : 0),
                decode: (value) => value === 1,
            },
        };
    }
    const typeInfo = numericTypeMap[storageType];
    if (!typeInfo) {
        throw new Error(`Unsupported storage type for column ${column.name}: ${storageType}`);
    }
    const bendecField = { name: column.name, type: typeInfo.bendecType };
    if (column.columnType === 'date') {
        return {
            name: column.name,
            storageType,
            nullable,
            nullFlagKey,
            defaultValue: BigInt(0),
            bendecField,
            transform: {
                encode: (value) => {
                    if (value instanceof Date) {
                        return BigInt(value.getTime());
                    }
                    if (typeof value === 'number') {
                        return BigInt(value);
                    }
                    if (typeof value === 'bigint') {
                        return value;
                    }
                    return BigInt(0);
                },
                decode: (value) => {
                    const millis = typeof value === 'bigint' ? Number(value) : value;
                    return new Date(millis);
                },
            },
        };
    }
    if (storageType === 'int64' || storageType === 'uint64') {
        return {
            name: column.name,
            storageType,
            nullable,
            nullFlagKey,
            defaultValue: typeInfo.defaultValue,
            bendecField,
            transform: {
                encode: (value) => {
                    if (value === undefined || value === null) {
                        return typeInfo.defaultValue;
                    }
                    if (typeof value === 'bigint') {
                        return value;
                    }
                    if (typeof value === 'number') {
                        return BigInt(value);
                    }
                    if (typeof value === 'string' && value !== '') {
                        try {
                            return BigInt(value);
                        }
                        catch (err) {
                            return typeInfo.defaultValue;
                        }
                    }
                    return typeInfo.defaultValue;
                },
                decode: (value) => {
                    if (typeof value === 'bigint') {
                        const asNumber = Number(value);
                        return Number.isSafeInteger(asNumber) ? asNumber : value;
                    }
                    return value;
                },
            },
        };
    }
    return {
        name: column.name,
        storageType,
        nullable,
        nullFlagKey,
        defaultValue: typeInfo.defaultValue,
        bendecField,
    };
}
function resolvePrimaryKey(columns) {
    const pk = columns.find(col => col.primaryKey);
    return pk?.name || columns[0]?.name || 'id';
}
function buildSharedMemorySchema(columns, rowTypeName) {
    if (columns.length === 0) {
        throw new Error('Shared memory store requires at least one column');
    }
    const typeDefinitions = [...primitiveDefinitions];
    const needsRemovedColumn = !columns.some(column => column.name === 'removed');
    const augmentedColumns = needsRemovedColumn
        ? [...columns, { name: 'removed', columnType: 'boolean', storage: { nullable: false } }]
        : columns.slice();
    const normalizedColumns = augmentedColumns.map(normalizeColumn);
    const fields = [
        { name: '__meta', type: 'u8' },
    ];
    for (const column of normalizedColumns) {
        fields.push(column.bendecField);
        if (column.nullable) {
            fields.push({ name: column.nullFlagKey, type: 'u8' });
        }
    }
    typeDefinitions.push({
        name: rowTypeName,
        fields,
    });
    const schemaDefinition = {
        types: typeDefinitions,
    };
    return {
        schemaDefinition,
        columns: normalizedColumns,
        primaryKey: resolvePrimaryKey(columns),
    };
}
exports.buildSharedMemorySchema = buildSharedMemorySchema;
//# sourceMappingURL=sharedSchema.js.map