"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedMemoryStore = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const sharedSchema_1 = require("./sharedSchema");
function resolveBendecCtor(shmioModule) {
    if (shmioModule && typeof shmioModule.getBendec === 'function') {
        const candidate = shmioModule.getBendec();
        if (typeof candidate === 'function') {
            return candidate;
        }
        if (candidate && typeof candidate.Bendec === 'function') {
            return candidate.Bendec;
        }
    }
    // Fallback to direct import
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const bendecPkg = require('bendec');
    if (bendecPkg && typeof bendecPkg.Bendec === 'function') {
        return bendecPkg.Bendec;
    }
    throw new Error('Unable to resolve Bendec constructor');
}
class SharedMemoryStore {
    mode = 'shared-memory';
    options;
    bendec;
    rowTypeName = 'TesseractRow';
    sharedLog;
    writer;
    normalizedColumns;
    frameSize;
    frames = [];
    get dataCache() {
        return new Proxy(this.frames, {
            get: (target, prop) => {
                return Reflect.get(target, prop);
            },
        });
    }
    constructor(columns, options) {
        const directory = options.directory || '/dev/shm';
        const resolvedOptions = {
            id: options.id,
            segmentSize: options.segmentSize ?? 16 * 1024 * 1024,
            directory,
            writable: options.writable ?? true,
        };
        if (!fs_1.default.existsSync(directory)) {
            fs_1.default.mkdirSync(directory, { recursive: true });
        }
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const shmio = require('shmio');
        const createSharedLog = shmio.createSharedLog;
        if (typeof createSharedLog !== 'function') {
            throw new Error('shmio.createSharedLog is not available');
        }
        const BendecCtor = resolveBendecCtor(shmio);
        const schema = (0, sharedSchema_1.buildSharedMemorySchema)(columns, this.rowTypeName);
        const bendecInstance = new BendecCtor(schema.schemaDefinition);
        const frameSize = bendecInstance.getSize(this.rowTypeName);
        if (typeof frameSize !== 'number' || frameSize <= 0) {
            throw new Error('Invalid Bendec frame size resolved for shared memory store');
        }
        const logPath = path_1.default.join(directory, `${options.id}.tesseract.shm`);
        const log = createSharedLog({
            path: logPath,
            capacityBytes: BigInt(resolvedOptions.segmentSize),
            writable: resolvedOptions.writable,
        });
        const writer = log.writer;
        if (!writer) {
            throw new Error('Shared memory log writer is not available (writable flag disabled)');
        }
        this.options = resolvedOptions;
        this.bendec = bendecInstance;
        this.sharedLog = log;
        this.writer = writer;
        this.normalizedColumns = schema.columns;
        this.frameSize = frameSize;
    }
    updateColumns(columns) {
        // Shared memory stores have a fixed schema defined at creation time.
        // Changing columns would require recreating the entire shared memory segment
        // with a new schema, which is not supported for active stores.
        throw new Error('updateColumns is not supported for SharedMemoryStore. ' +
            'The schema is fixed at creation time. Create a new store instance to use different columns.');
    }
    prepareForReset() {
        this.frames = [];
    }
    clear() {
        if (this.sharedLog) {
            try {
                this.sharedLog.close();
            }
            catch (_) {
                // Ignore close errors.
            }
        }
    }
    isRowInstance(candidate) {
        return this.dataCache.includes(candidate);
    }
    createRowInstance() {
        const frame = this.writer?.allocate(this.frameSize);
        const view = this.bendec.wrap(this.rowTypeName, frame);
        this.writer?.commit();
        return view;
    }
}
exports.SharedMemoryStore = SharedMemoryStore;
//# sourceMappingURL=sharedMemoryStore.js.map