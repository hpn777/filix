"use strict";
/*
MIT License

Copyright (c) 2019 Rafal Okninski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.Collection = exports.Model = exports.Events = void 0;
const _ = __importStar(require("lodash"));
// Regular expression used to split event strings
const eventSplitter = /\s+/;
// Proxy Backbone class methods to Underscore functions
const addMethod = function (length, method, attribute) {
    switch (length) {
        case 1: return function () {
            return _[method](this[attribute]);
        };
        case 2: return function (value) {
            return _[method](this[attribute], value);
        };
        case 3: return function (iteratee, context) {
            return _[method](this[attribute], cb(iteratee, this), context);
        };
        case 4: return function (iteratee, defaultVal, context) {
            return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
        };
        default: return function (...args) {
            const newArgs = [this[attribute], ...args];
            return _[method].apply(_, newArgs);
        };
    }
};
const addUnderscoreMethods = function (Class, methods, attribute) {
    _.each(methods, function (length, method) {
        if (_[method]) {
            Class.prototype[method] = addMethod(length, method, attribute);
        }
    });
};
// Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`
const cb = function (iteratee, instance) {
    if (_.isFunction(iteratee))
        return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee))
        return modelMatcher(iteratee);
    if (_.isString(iteratee))
        return function (model) { return model.get(iteratee); };
    return iteratee;
};
const modelMatcher = function (attrs) {
    const matcher = _.matches(attrs);
    return function (model) {
        return matcher(model.attributes);
    };
};
// Events API
const eventsApi = function (iteratee, events, name, callback, opts) {
    let i = 0;
    let names;
    if (name && typeof name === 'object') {
        // Handle event maps
        if (callback !== void 0 && 'context' in (opts || {}) && opts.context === void 0) {
            opts.context = callback;
        }
        names = _.keys(name);
        for (; i < names.length; i++) {
            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
        }
    }
    else if (name && eventSplitter.test(name)) {
        // Handle space-separated event names
        names = name.split(eventSplitter);
        for (; i < names.length; i++) {
            events = iteratee(events, names[i], callback, opts);
        }
    }
    else {
        // Standard events
        events = iteratee(events, name, callback, opts);
    }
    return events;
};
// Internal on function
const internalOn = function (obj, name, callback, context, listening) {
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
        context: context,
        ctx: obj,
        listening: listening
    });
    if (listening) {
        const listeners = obj._listeners || (obj._listeners = {});
        listeners[listening.id] = listening;
    }
    return obj;
};
// The reducing API that adds a callback to the `events` object
const onApi = function (events, name, callback, options) {
    if (callback) {
        const handlers = events[name] || (events[name] = []);
        const context = options?.context;
        const ctx = options?.ctx;
        const listening = options?.listening;
        if (listening)
            listening.count++;
        handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
    }
    return events;
};
// The reducing API that removes a callback from the `events` object
const offApi = function (events, name, callback, options) {
    if (!events)
        return;
    let i = 0;
    let listening;
    const context = options?.context;
    const listeners = options?.listeners;
    // Delete all events listeners and "drop" events
    if (!name && !callback && !context) {
        const ids = _.keys(listeners);
        for (; i < ids.length; i++) {
            listening = listeners[ids[i]];
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
        }
        return;
    }
    const names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
        name = names[i];
        const handlers = events[name];
        // Bail out if there are no events stored
        if (!handlers)
            break;
        // Replace events if there are any remaining. Otherwise, clean up.
        const remaining = [];
        for (let j = 0; j < handlers.length; j++) {
            const handler = handlers[j];
            if (callback && callback !== handler.callback &&
                callback !== handler.callback._callback ||
                context && context !== handler.context) {
                remaining.push(handler);
            }
            else {
                listening = handler.listening;
                if (listening && --listening.count === 0) {
                    delete listeners[listening.id];
                    delete listening.listeningTo[listening.objId];
                }
            }
        }
        // Update tail event if the list has any events. Otherwise, clean up.
        if (remaining.length) {
            events[name] = remaining;
        }
        else {
            delete events[name];
        }
    }
    return events;
};
// Reduces the event callbacks into a map of `{event: onceWrapper}`
const onceMap = function (map, name, callback, offer) {
    if (callback) {
        const once = map[name] = _.once(function (...args) {
            offer && offer(name, once);
            return callback.apply(this, args);
        });
        once._callback = callback;
    }
    return map;
};
const triggerEvents = function (events, ...args) {
    let ev;
    let i = events.length;
    while (--i > -1) {
        ev = events[i];
        ev.callback.call(ev.ctx, ...args);
    }
};
// Events mixin
exports.Events = {
    // Bind an event to a `callback` function
    on: function (name, callback, context) {
        return internalOn(this, name, callback, context);
    },
    // Inversion-of-control versions of `on`
    listenTo: function (obj, name, callback) {
        if (!obj)
            return this;
        const id = obj._listenId || (obj._listenId = _.uniqueId('l'));
        const listeningTo = this._listeningTo || (this._listeningTo = {});
        let listening = listeningTo[id];
        // This object is not listening to any other events on `obj` yet
        if (!listening) {
            const thisId = this._listenId || (this._listenId = _.uniqueId('l'));
            listening = listeningTo[id] = { obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0 };
        }
        // Bind callbacks on obj, and keep track of them on listening
        internalOn(obj, name, callback, this, listening);
        return this;
    },
    // Remove one or many callbacks
    off: function (name, callback, context) {
        if (!this._events)
            return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
            context: context,
            listeners: this._listeners
        });
        return this;
    },
    // Tell this object to stop listening to either specific events or to every object it's currently listening to
    stopListening: function (obj, name, callback) {
        const listeningTo = this._listeningTo;
        if (!listeningTo)
            return this;
        const ids = obj ? [obj._listenId] : _.keys(listeningTo);
        for (let i = 0; i < ids.length; i++) {
            const listening = listeningTo[ids[i]];
            // If listening doesn't exist, this object is not currently listening to obj
            if (!listening)
                break;
            listening.obj.off(name, callback, this);
        }
        return this;
    },
    // Bind an event to only be triggered a single time
    once: function (name, callback, context) {
        // Map the event into a `{event: once}` object
        const events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        if (typeof name === 'string' && context == null)
            callback = void 0;
        return this.on(events, callback, context);
    },
    // Inversion-of-control versions of `once`
    listenToOnce: function (obj, name, callback) {
        // Map the event into a `{event: once}` object
        const events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
    },
    // Trigger one or many events, firing all bound callbacks
    trigger: function (name, ...args) {
        const objEvents = this._events;
        if (!objEvents)
            return this;
        const allEvents = objEvents.all;
        const events = objEvents[name];
        if (events) {
            triggerEvents(events, ...args);
        }
        if (allEvents) {
            triggerEvents(allEvents, name, ...args);
        }
        return this;
    },
    // Aliases for backwards compatibility
    bind: function (...args) { return this.on(...args); },
    unbind: function (...args) { return this.off(...args); },
    // DOM-style event methods
    addEventListener: function (name, handler, ref) {
        this.on(name, handler, ref);
    },
    removeEventListener: function (name, handler, ref) {
        this.off(name, handler, ref);
    }
};
// Backbone **Models** are the basic data object in the framework
class Model {
    attributes = {};
    changed = null;
    validationError = null;
    idAttribute = 'id';
    cidPrefix = 'c';
    cid;
    id;
    collection;
    // Event system properties
    _events;
    _listeners;
    _listeningTo;
    _listenId;
    _previousAttributes;
    _pending;
    _changing;
    // Event methods (will be mixed in)
    on;
    off;
    trigger;
    listenTo;
    stopListening;
    once;
    listenToOnce;
    bind;
    unbind;
    addEventListener;
    removeEventListener;
    constructor(attributes, options) {
        const attrs = attributes || {};
        options = options || {};
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        // Initialize event methods before calling set() which uses trigger()
        this.on = exports.Events.on.bind(this);
        this.off = exports.Events.off.bind(this);
        this.trigger = exports.Events.trigger.bind(this);
        this.listenTo = exports.Events.listenTo.bind(this);
        this.stopListening = exports.Events.stopListening.bind(this);
        this.once = exports.Events.once.bind(this);
        this.listenToOnce = exports.Events.listenToOnce.bind(this);
        this.bind = exports.Events.bind.bind(this);
        this.unbind = exports.Events.unbind.bind(this);
        this.addEventListener = exports.Events.addEventListener.bind(this);
        this.removeEventListener = exports.Events.removeEventListener.bind(this);
        if (options.collection)
            this.collection = options.collection;
        if (options.parse) {
            const parsed = this.parse(attrs, options);
            if (parsed)
                Object.assign(attrs, parsed);
        }
        const defaults = _.result(this, 'defaults');
        const finalAttrs = _.defaults(_.extend({}, defaults, attrs), defaults);
        this.set(finalAttrs, options);
        this.changed = {};
        this.initialize.apply(this, [attributes, options]);
    }
    // Initialize is an empty function by default. Override it with your own initialization logic.
    initialize(..._args) { }
    // Return a copy of the model's `attributes` object
    toJSON(_options) {
        return _.clone(this.attributes);
    }
    // Get the value of an attribute
    get(attr) {
        return this.attributes[attr];
    }
    // Get the HTML-escaped value of an attribute
    escape(attr) {
        return _.escape(this.get(attr));
    }
    // Returns `true` if the attribute contains a value that is not null or undefined
    has(attr) {
        return this.get(attr) != null;
    }
    // Special-cased proxy to underscore's `_.matches` method
    matches(attrs) {
        return !!_.iteratee(attrs)(this.attributes);
    }
    // Set a hash of model attributes on the object, firing `"change"`
    set(key, val, options) {
        if (key == null)
            return this;
        // Handle both `"key", value` and `{key: value}` -style arguments
        let attrs;
        if (typeof key === 'object') {
            attrs = key;
            options = val;
        }
        else {
            attrs = {};
            attrs[key] = val;
        }
        options = options || {};
        // Run validation
        if (!this._validate(attrs, options))
            return false;
        // Extract attributes and options
        const unset = options.unset;
        const silent = options.silent;
        const changes = [];
        const changing = this._changing;
        this._changing = true;
        if (!changing) {
            this._previousAttributes = _.clone(this.attributes);
            this.changed = {};
        }
        const current = this.attributes;
        const changed = this.changed;
        const prev = this._previousAttributes;
        // For each `set` attribute, update or delete the current value
        for (const attr in attrs) {
            val = attrs[attr];
            if (!_.isEqual(current[attr], val))
                changes.push(attr);
            if (!_.isEqual(prev[attr], val)) {
                changed[attr] = val;
            }
            else {
                delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
        }
        // Update the `id`
        if (this.idAttribute in attrs)
            this.id = this.get(this.idAttribute);
        // Trigger all relevant attribute changes
        if (!silent) {
            if (changes.length)
                this._pending = options;
            for (let i = 0; i < changes.length; i++) {
                this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
        }
        // You might be wondering why there's a `while` loop here. Changes can be recursively nested within `"change"` events.
        if (changing)
            return this;
        if (!silent) {
            while (this._pending) {
                options = this._pending;
                this._pending = false;
                this.trigger('change', this, options);
            }
        }
        this._pending = false;
        this._changing = false;
        return this;
    }
    // Remove an attribute from the model, firing `"change"`
    unset(attr, options) {
        return this.set(attr, void 0, _.extend({}, options, { unset: true }));
    }
    // Clear all attributes on the model, firing `"change"`
    clear(options) {
        const attrs = {};
        for (const key in this.attributes)
            attrs[key] = void 0;
        return this.set(attrs, _.extend({}, options, { unset: true }));
    }
    // Determine if the model has changed since the last `"change"` event
    hasChanged(attr) {
        if (attr == null)
            return !_.isEmpty(this.changed);
        return _.has(this.changed, attr);
    }
    // Return an object containing all the attributes that have changed
    changedAttributes(diff) {
        if (!diff)
            return this.hasChanged() ? _.clone(this.changed) : false;
        const old = this._changing ? this._previousAttributes : this.attributes;
        const changed = {};
        for (const attr in diff) {
            const val = diff[attr];
            if (_.isEqual(old[attr], val))
                continue;
            changed[attr] = val;
        }
        return _.size(changed) ? changed : false;
    }
    // Get the previous value of an attribute, recorded at the time the last `"change"` event was fired
    previous(attr) {
        if (attr == null || !this._previousAttributes)
            return null;
        return this._previousAttributes[attr];
    }
    // Get all of the attributes of the model at the time of the previous `"change"` event
    previousAttributes() {
        return _.clone(this._previousAttributes);
    }
    // Destroy this model on the server if it was already persisted
    destroy(options) {
        this.stopListening();
        this.trigger('destroy', this, options);
    }
    // **parse** converts a response into the hash of attributes to be `set` on the model
    parse(resp, _options) {
        return resp;
    }
    // Create a new model with identical attributes to this one
    clone() {
        return new this.constructor(this.attributes);
    }
    // A model is new if it has never been saved to the server, and lacks an id
    isNew() {
        return !this.has(this.idAttribute);
    }
    // Check if the model is currently in a valid state
    isValid(options) {
        return this._validate({}, _.extend({}, options, { validate: true }));
    }
    // Run validation against the next complete set of model attributes
    _validate(attrs, options) {
        if (!options?.validate || !this.validate)
            return true;
        attrs = _.extend({}, this.attributes, attrs);
        const error = this.validationError = this.validate(attrs, options) || null;
        if (!error)
            return true;
        this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
        return false;
    }
}
exports.Model = Model;
exports.default = Model;
// Mix in Events methods to Model
Object.assign(Model.prototype, exports.Events);
// Also assign individual methods to ensure they're properly attached
Model.prototype.on = exports.Events.on;
Model.prototype.off = exports.Events.off;
Model.prototype.trigger = exports.Events.trigger;
Model.prototype.listenTo = exports.Events.listenTo;
Model.prototype.stopListening = exports.Events.stopListening;
Model.prototype.once = exports.Events.once;
Model.prototype.listenToOnce = exports.Events.listenToOnce;
Model.prototype.bind = exports.Events.bind;
Model.prototype.unbind = exports.Events.unbind;
Model.prototype.addEventListener = exports.Events.addEventListener;
Model.prototype.removeEventListener = exports.Events.removeEventListener;
// Underscore methods that we want to implement on the Model
const modelMethods = {
    keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
    omit: 0, chain: 1, isEmpty: 1
};
// Mix in each Underscore method as a proxy to `Model#attributes`
addUnderscoreMethods(Model, modelMethods, 'attributes');
// Default options for `Collection#set`
const setOptions = { add: true, remove: true, merge: true };
const addOptions = { add: true, remove: false };
// Splices `insert` into `array` at index `at`
const splice = function (array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    const tail = Array(array.length - at);
    const length = insert.length;
    let i;
    for (i = 0; i < tail.length; i++)
        tail[i] = array[i + at];
    for (i = 0; i < length; i++)
        array[i + at] = insert[i];
    for (i = 0; i < tail.length; i++)
        array[i + length + at] = tail[i];
};
// Backbone Collection
class Collection {
    model = Model;
    models = [];
    length = 0;
    comparator;
    // Event system properties
    _events;
    _listeners;
    _listeningTo;
    _listenId;
    _byId = {};
    // Event methods (will be mixed in)
    on;
    off;
    trigger;
    listenTo;
    stopListening;
    once;
    listenToOnce;
    bind;
    unbind;
    addEventListener;
    removeEventListener;
    // Underscore methods (will be mixed in)
    map;
    forEach;
    filter;
    find;
    constructor(models, options) {
        options = options || {};
        // Initialize event methods before any operations that might trigger events
        this.on = exports.Events.on.bind(this);
        this.off = exports.Events.off.bind(this);
        this.trigger = exports.Events.trigger.bind(this);
        this.listenTo = exports.Events.listenTo.bind(this);
        this.stopListening = exports.Events.stopListening.bind(this);
        this.once = exports.Events.once.bind(this);
        this.listenToOnce = exports.Events.listenToOnce.bind(this);
        this.bind = exports.Events.bind.bind(this);
        this.unbind = exports.Events.unbind.bind(this);
        this.addEventListener = exports.Events.addEventListener.bind(this);
        this.removeEventListener = exports.Events.removeEventListener.bind(this);
        // Initialize underscore methods before any operations that might use them
        this.forEach = (iteratee, context) => _.forEach(this.models, cb(iteratee, this), context);
        this.map = (iteratee, context) => _.map(this.models, cb(iteratee, this), context);
        this.filter = (iteratee, context) => _.filter(this.models, cb(iteratee, this), context);
        this.find = (iteratee, context) => _.find(this.models, cb(iteratee, this), context);
        if (options.model)
            this.model = options.model;
        if (options.comparator !== void 0)
            this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, [models, options]);
        if (models)
            this.reset(models, _.extend({ silent: true }, options));
    }
    // Initialize is an empty function by default
    initialize(..._args) { }
    // The JSON representation of a Collection is an array of the models' attributes
    toJSON(options) {
        return this.map(function (model) { return model.toJSON(options); });
    }
    // Add a model, or list of models to the set
    add(models, options) {
        return this.set(models, _.extend({ merge: false }, options, addOptions));
    }
    // Remove a model, or a list of models from the set
    remove(models, options) {
        options = _.extend({}, options);
        const singular = !_.isArray(models);
        const modelsArray = singular ? [models] : models.slice();
        const removed = this._removeModels(modelsArray, options);
        if (!options.silent && removed.length) {
            options.changes = { added: [], merged: [], removed: removed };
            this.trigger('update', this, options);
        }
        return singular ? removed[0] : removed;
    }
    // Update a collection by `set`-ing a new list of models
    set(models, options) {
        if (models == null)
            return [];
        options = _.extend({}, setOptions, options);
        if (options.parse && !this._isModel(models)) {
            models = this.parse(models, options) || [];
        }
        const singular = !_.isArray(models);
        const modelsArray = singular ? [models] : models.slice();
        let at = options.at;
        if (at != null) {
            at = +at;
            if (at > this.length)
                at = this.length;
            if (at < 0)
                at += this.length + 1;
        }
        const set = [];
        const toAdd = [];
        const toMerge = [];
        const toRemove = [];
        const modelMap = {};
        const add = options.add;
        const merge = options.merge;
        const remove = options.remove;
        let sort = false;
        const sortable = this.comparator && at == null && options.sort !== false;
        const sortAttr = _.isString(this.comparator) ? this.comparator : null;
        // Turn bare objects into model references, and prevent invalid models from being added
        let model;
        let i;
        for (i = 0; i < modelsArray.length; i++) {
            model = modelsArray[i];
            // If a duplicate is found, prevent it from being added and optionally merge it into the existing model
            const existing = this.get(model);
            if (existing) {
                if (merge && model !== existing) {
                    let attrs = this._isModel(model) ? model.attributes : model;
                    if (options.parse)
                        attrs = existing.parse(attrs, options);
                    existing.set(attrs, options);
                    toMerge.push(existing);
                    if (sortable && !sort)
                        sort = existing.hasChanged(sortAttr);
                }
                if (!modelMap[existing.cid]) {
                    modelMap[existing.cid] = true;
                    set.push(existing);
                }
                modelsArray[i] = existing;
                // If this is a new, valid model, push it to the `toAdd` list
            }
            else if (add) {
                const preparedModel = this._prepareModel(model, options);
                if (preparedModel) {
                    model = modelsArray[i] = preparedModel;
                    toAdd.push(preparedModel);
                    this._addReference(preparedModel, options);
                    modelMap[preparedModel.cid] = true;
                    set.push(preparedModel);
                }
            }
        }
        // Remove stale models
        if (remove) {
            for (i = 0; i < this.length; i++) {
                model = this.models[i];
                if (!modelMap[model.cid])
                    toRemove.push(model);
            }
            if (toRemove.length)
                this._removeModels(toRemove, options);
        }
        // See if sorting is needed, update `length` and splice in new models
        let orderChanged = false;
        const replace = !sortable && add && remove;
        if (set.length && replace) {
            orderChanged = this.length !== set.length || _.some(this.models, function (m, index) {
                return m !== set[index];
            });
            this.models.length = 0;
            splice(this.models, set, 0);
            this.length = this.models.length;
        }
        else if (toAdd.length) {
            if (sortable)
                sort = true;
            splice(this.models, toAdd, at == null ? this.length : at);
            this.length = this.models.length;
        }
        // Silently sort the collection if appropriate
        if (sort)
            this.sort({ silent: true });
        // Unless silenced, it's time to fire all appropriate add/sort/update events
        if (!options.silent) {
            for (i = 0; i < toAdd.length; i++) {
                if (at != null)
                    options.index = at + i;
                model = toAdd[i];
                model.trigger('add', model, this, options);
            }
            if (sort || orderChanged)
                this.trigger('sort', this, options);
            if (toAdd.length || toRemove.length || toMerge.length) {
                options.changes = {
                    added: toAdd,
                    removed: toRemove,
                    merged: toMerge
                };
                this.trigger('update', this, options);
            }
        }
        // Return the added (or merged) model (or models)
        return singular ? modelsArray[0] : modelsArray;
    }
    // When you have more items than you want to add or remove individually, you can reset the entire set
    reset(models, options) {
        options = options ? _.clone(options) : {};
        for (let i = 0; i < this.models.length; i++) {
            this._removeReference(this.models[i], options);
        }
        options.previousModels = this.models;
        this._reset();
        const result = this.add(models, _.extend({ silent: true }, options));
        if (!options.silent)
            this.trigger('reset', this, options);
        return result;
    }
    // Add a model to the end of the collection
    push(model, options) {
        return this.add(model, _.extend({ at: this.length }, options));
    }
    // Remove a model from the end of the collection
    pop(options) {
        const model = this.at(this.length - 1);
        return this.remove(model, options);
    }
    // Add a model to the beginning of the collection
    unshift(model, options) {
        return this.add(model, _.extend({ at: 0 }, options));
    }
    // Remove a model from the beginning of the collection
    shift(options) {
        const model = this.at(0);
        return this.remove(model, options);
    }
    // Slice out a sub-array of models from the collection
    slice(start, end) {
        return this.models.slice(start, end);
    }
    // Get a model from the set by id, cid, model object with id or cid properties, or an attributes object
    get(obj) {
        if (obj == null)
            return void 0;
        return this._byId[obj] ||
            this._byId[this.modelId(obj.attributes || obj)] ||
            obj.cid && this._byId[obj.cid];
    }
    // Returns `true` if the model is in the collection
    has(obj) {
        return this.get(obj) != null;
    }
    // Get the model at the given index
    at(index) {
        if (index < 0)
            index += this.length;
        return this.models[index];
    }
    // Return models with matching attributes
    where(attrs, first) {
        return this[first ? 'find' : 'filter'](attrs);
    }
    // Return the first model with matching attributes
    findWhere(attrs) {
        return this.where(attrs, true);
    }
    // Force the collection to re-sort itself
    sort(options) {
        let comparator = this.comparator;
        if (!comparator)
            throw new Error('Cannot sort a set without a comparator');
        options = options || {};
        const length = comparator.length;
        if (_.isFunction(comparator))
            comparator = _.bind(comparator, this);
        // Run sort based on type of `comparator`
        if (length === 1 || _.isString(comparator)) {
            this.models = this.sortBy(comparator);
        }
        else {
            this.models.sort(comparator);
        }
        if (!options.silent)
            this.trigger('sort', this, options);
        return this;
    }
    // Pluck an attribute from each model in the collection
    pluck(attr) {
        return this.map(attr + '');
    }
    // Create a new instance of a model in this collection
    create(model, options) {
        options = options ? _.clone(options) : {};
        const wait = options.wait;
        const preparedModel = this._prepareModel(model, options);
        if (!preparedModel)
            return false;
        if (!wait)
            this.add(preparedModel, options);
        const collection = this;
        const success = options.success;
        options.success = function (m, resp, callbackOpts) {
            if (wait)
                collection.add(m, callbackOpts);
            if (success)
                success.call(callbackOpts.context, m, resp, callbackOpts);
        };
        preparedModel.save(null, options);
        return preparedModel;
    }
    // **parse** converts a response into a list of models to be added to the collection
    parse(resp, _options) {
        return resp;
    }
    // Create a new collection with an identical list of models as this one
    clone() {
        return new this.constructor(this.models, {
            model: this.model,
            comparator: this.comparator
        });
    }
    // Define how to uniquely identify models in the collection
    modelId(attrs) {
        return attrs[this.model.prototype.idAttribute || 'id'];
    }
    // Private method to reset all internal state
    _reset() {
        this.length = 0;
        this.models = [];
        this._byId = {};
    }
    // Prepare a hash of attributes (or other model) to be added to this collection
    _prepareModel(attrs, options) {
        if (this._isModel(attrs)) {
            if (!attrs.collection)
                attrs.collection = this;
            return attrs;
        }
        options = options ? _.clone(options) : {};
        options.collection = this;
        const model = new this.model(attrs, options);
        if (!model.validationError)
            return model;
        this.trigger('invalid', this, model.validationError, options);
        return false;
    }
    // Internal method called by both remove and set
    _removeModels(models, options) {
        const removed = [];
        for (let i = 0; i < models.length; i++) {
            const model = this.get(models[i]);
            if (!model)
                continue;
            const index = this.indexOf(model);
            this.models.splice(index, 1);
            this.length--;
            // Remove references before triggering 'remove' event to prevent an infinite loop
            delete this._byId[model.cid];
            const id = this.modelId(model.attributes);
            if (id != null)
                delete this._byId[id];
            if (!options?.silent) {
                options.index = index;
                model.trigger('remove', model, this, options);
            }
            removed.push(model);
            this._removeReference(model, options);
        }
        return removed;
    }
    // Method for checking whether an object should be considered a model
    _isModel(model) {
        return model instanceof Model;
    }
    // Internal method to create a model's ties to a collection
    _addReference(model, _options) {
        this._byId[model.cid] = model;
        const id = this.modelId(model.attributes);
        if (id != null)
            this._byId[id] = model;
        model.on('all', this._onModelEvent, this);
    }
    // Internal method to sever a model's ties to a collection
    _removeReference(model, _options) {
        delete this._byId[model.cid];
        const id = this.modelId(model.attributes);
        if (id != null)
            delete this._byId[id];
        if (this === model.collection)
            delete model.collection;
        model.off('all', this._onModelEvent, this);
    }
    // Internal method called every time a model in the set fires an event
    _onModelEvent(event, model, collection, options) {
        if (model) {
            if ((event === 'add' || event === 'remove') && collection !== this)
                return;
            if (event === 'destroy') {
                this.remove(model, options);
            }
            if (event === 'change') {
                const prevId = this.modelId(model.previousAttributes());
                const id = this.modelId(model.attributes);
                if (prevId !== id) {
                    if (prevId != null)
                        delete this._byId[prevId];
                    if (id != null)
                        this._byId[id] = model;
                }
            }
        }
        this.trigger.apply(this, [event, ...Array.prototype.slice.call(arguments, 1)]);
    }
    // Add array methods and underscore methods
    indexOf(model) { return this.models.indexOf(model); }
}
exports.Collection = Collection;
// Mix in Events methods to Collection
Object.assign(Collection.prototype, exports.Events);
// Also assign individual methods to ensure they're properly attached
Collection.prototype.on = exports.Events.on;
Collection.prototype.off = exports.Events.off;
Collection.prototype.trigger = exports.Events.trigger;
Collection.prototype.listenTo = exports.Events.listenTo;
Collection.prototype.stopListening = exports.Events.stopListening;
Collection.prototype.once = exports.Events.once;
Collection.prototype.listenToOnce = exports.Events.listenToOnce;
Collection.prototype.bind = exports.Events.bind;
Collection.prototype.unbind = exports.Events.unbind;
Collection.prototype.addEventListener = exports.Events.addEventListener;
Collection.prototype.removeEventListener = exports.Events.removeEventListener;
// Underscore methods that we want to implement on the Collection
const collectionMethods = {
    forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
    foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
    select: 3, reject: 3, every: 3, all: 3, some: 3, include: 3, includes: 3,
    contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
    head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
    without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
    isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
    sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3
};
// Mix in each Underscore method as a proxy to `Collection#models`
addUnderscoreMethods(Collection, collectionMethods, 'models');
// Helper function to correctly set up the prototype chain for subclasses
const extend = function (protoProps, staticProps) {
    const parent = this;
    let child;
    // The constructor function for the new subclass
    if (protoProps && _.has(protoProps, 'constructor')) {
        child = protoProps.constructor;
    }
    else {
        child = function (...args) { return parent.apply(this, args); };
    }
    // Add static properties to the constructor function, if supplied
    _.extend(child, parent, staticProps);
    // Set the prototype chain to inherit from `parent`
    child.prototype = _.create(parent.prototype, protoProps);
    child.prototype.constructor = child;
    // Set a convenience property in case the parent's prototype is needed later
    child.__super__ = parent.prototype;
    return child;
};
// Set up inheritance for the model and collection
Model.extend = extend;
Collection.extend = extend;
//# sourceMappingURL=backbone.js.map