export interface ModelAttributes {
    [key: string]: any;
}
export interface ModelOptions {
    collection?: Collection;
    parse?: boolean;
    [key: string]: any;
}
export interface CollectionOptions {
    model?: typeof Model;
    comparator?: string | ((model: Model) => any) | ((a: Model, b: Model) => number);
    [key: string]: any;
}
export interface SetOptions {
    add?: boolean;
    remove?: boolean;
    merge?: boolean;
    at?: number;
    sort?: boolean;
    silent?: boolean;
    parse?: boolean;
    unset?: boolean;
    index?: number;
    changes?: {
        added: Model[];
        removed: Model[];
        merged: Model[];
    };
    [key: string]: any;
}
interface EventHandler {
    callback: Function;
    context?: any;
    ctx?: any;
    listening?: ListeningState;
}
interface ListeningState {
    obj: any;
    objId: string;
    id: string;
    listeningTo: {
        [id: string]: ListeningState;
    };
    count: number;
}
export declare const Events: {
    on: (this: any, name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => any;
    listenTo: (this: any, obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function) => any;
    off: (this: any, name?: string | {
        [key: string]: Function;
    } | undefined, callback?: Function, context?: any) => any;
    stopListening: (this: any, obj?: any, name?: string | {
        [key: string]: Function;
    } | undefined, callback?: Function) => any;
    once: (this: any, name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => any;
    listenToOnce: (this: any, obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function) => any;
    trigger: (this: any, name: string, ...args: any[]) => any;
    bind: (this: any, ...args: any[]) => any;
    unbind: (this: any, ...args: any[]) => any;
    addEventListener: (this: any, name: string, handler: Function, ref?: any) => void;
    removeEventListener: (this: any, name: string, handler: Function, ref?: any) => void;
};
interface EventEmitter {
    on(name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any): this;
    off(name?: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any): this;
    trigger(name: string, ...args: any[]): this;
    listenTo(obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function): this;
    stopListening(obj?: any, name?: string | {
        [key: string]: Function;
    }, callback?: Function): this;
    once(name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any): this;
    listenToOnce(obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function): this;
    bind(...args: any[]): this;
    unbind(...args: any[]): this;
    addEventListener(name: string, handler: Function, ref?: any): void;
    removeEventListener(name: string, handler: Function, ref?: any): void;
}
export declare class Model implements EventEmitter {
    attributes: ModelAttributes;
    changed: ModelAttributes | null;
    validationError: any;
    idAttribute: string;
    cidPrefix: string;
    cid: string;
    id?: any;
    collection?: Collection;
    _events?: {
        [eventName: string]: EventHandler[];
    };
    _listeners?: {
        [id: string]: ListeningState;
    };
    _listeningTo?: {
        [id: string]: ListeningState;
    };
    _listenId?: string;
    private _previousAttributes?;
    private _pending?;
    private _changing?;
    on: (name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => this;
    off: (name?: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => this;
    trigger: (name: string, ...args: any[]) => this;
    listenTo: (obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function) => this;
    stopListening: (obj?: any, name?: string | {
        [key: string]: Function;
    }, callback?: Function) => this;
    once: (name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => this;
    listenToOnce: (obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function) => this;
    bind: (...args: any[]) => this;
    unbind: (...args: any[]) => this;
    addEventListener: (name: string, handler: Function, ref?: any) => void;
    removeEventListener: (name: string, handler: Function, ref?: any) => void;
    constructor(attributes?: ModelAttributes, options?: ModelOptions);
    initialize(..._args: any[]): void;
    toJSON(_options?: any): ModelAttributes;
    get(attr: string): any;
    escape(attr: string): string;
    has(attr: string): boolean;
    matches(attrs: ModelAttributes): boolean;
    set(key: string | ModelAttributes, val?: any, options?: SetOptions): this | false;
    unset(attr: string, options?: SetOptions): this | false;
    clear(options?: SetOptions): any;
    hasChanged(attr?: string): boolean;
    changedAttributes(diff?: ModelAttributes): ModelAttributes | false;
    previous(attr: string): any;
    previousAttributes(): ModelAttributes | null;
    destroy(options?: any): void;
    parse(resp: any, _options?: any): ModelAttributes;
    clone(): Model;
    isNew(): boolean;
    isValid(options?: any): boolean;
    private _validate;
    validate?(_attributes: ModelAttributes, _options?: any): any;
}
export declare class Collection implements EventEmitter {
    model: typeof Model;
    models: Model[];
    length: number;
    comparator?: string | ((model: Model) => any) | ((a: Model, b: Model) => number);
    _events?: {
        [eventName: string]: EventHandler[];
    };
    _listeners?: {
        [id: string]: ListeningState;
    };
    _listeningTo?: {
        [id: string]: ListeningState;
    };
    _listenId?: string;
    private _byId;
    on: (name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => this;
    off: (name?: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => this;
    trigger: (name: string, ...args: any[]) => this;
    listenTo: (obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function) => this;
    stopListening: (obj?: any, name?: string | {
        [key: string]: Function;
    }, callback?: Function) => this;
    once: (name: string | {
        [key: string]: Function;
    }, callback?: Function, context?: any) => this;
    listenToOnce: (obj: any, name: string | {
        [key: string]: Function;
    }, callback?: Function) => this;
    bind: (...args: any[]) => this;
    unbind: (...args: any[]) => this;
    addEventListener: (name: string, handler: Function, ref?: any) => void;
    removeEventListener: (name: string, handler: Function, ref?: any) => void;
    map: <T>(iteratee: (model: Model, index: number) => T) => T[];
    forEach: (iteratee: (model: Model, index: number) => void) => void;
    filter: (iteratee: (model: Model, index: number) => boolean) => Model[];
    find: (iteratee: (model: Model, index: number) => boolean) => Model | undefined;
    constructor(models?: Model[] | ModelAttributes[], options?: CollectionOptions);
    initialize(..._args: any[]): void;
    toJSON(options?: any): ModelAttributes[];
    add(models: Model | Model[] | ModelAttributes | ModelAttributes[], options?: SetOptions): Model | Model[];
    remove(models: Model | Model[], options?: any): Model | Model[];
    set(models: Model | Model[] | ModelAttributes | ModelAttributes[] | null | undefined, options?: SetOptions): Model | Model[];
    reset(models?: Model[] | ModelAttributes[], options?: any): Model[];
    push(model: Model | ModelAttributes, options?: SetOptions): Model;
    pop(options?: any): Model;
    unshift(model: Model | ModelAttributes, options?: SetOptions): Model;
    shift(options?: any): Model;
    slice(start?: number, end?: number): Model[];
    get(obj: any): Model | undefined;
    has(obj: any): boolean;
    at(index: number): Model | undefined;
    where(attrs: ModelAttributes, first?: boolean): Model[] | Model;
    findWhere(attrs: ModelAttributes): Model;
    sort(options?: any): this;
    pluck(attr: string): any[];
    create(model: Model | ModelAttributes, options?: any): Model | false;
    parse(resp: any, _options?: any): any;
    clone(): Collection;
    modelId(attrs: ModelAttributes): any;
    private _reset;
    private _prepareModel;
    private _removeModels;
    private _isModel;
    private _addReference;
    private _removeReference;
    private _onModelEvent;
    indexOf(model: Model): number;
}
export { Model as default };
