import { ExpressionTree } from "./lib/expressionEngine";
export type RowValue = string | number | boolean | Date | null | undefined | object;
export type PrimitiveValue = string | number | boolean | null | undefined;
export type AggregateValue = number | string | null | undefined;
export type EnumValue = string | number | boolean;
export type EnumDefinition = Record<string, EnumValue>;
export type IdValue = string | number;
export interface DataRow {
    [key: string]: RowValue;
}
export interface ResolveConfig {
    childrenTable?: string;
    underlyingField: string;
    displayField: string;
    valueField?: string;
    session?: string | CreateSessionParameters;
    template?: string;
    displayTemplate?: string;
}
export interface ColumnDef {
    name: string;
    primaryKey?: boolean;
    secondaryKey?: boolean | string;
    title?: string;
    aggregator?: 'sum' | 'avg' | 'max' | 'min' | 'count' | 'first' | 'last' | 'expression' | 'none' | Function;
    expression?: string;
    expressionTree?: ExpressionTree;
    columnType?: 'string' | 'number' | 'date' | 'boolean' | 'object' | 'text' | 'dimension' | 'metric' | 'enum';
    defaultValue?: string | number | Function | boolean | null;
    value?: string | number | Function | boolean | null;
    hidden?: boolean;
    enum?: EnumDefinition;
    resolve?: ResolveConfig;
}
export interface FilterDef {
    field: string;
    comparison?: '==' | '>' | '<' | '>=' | '<=' | '!=' | 'in' | 'notin' | 'like' | 'notlike' | '~' | '!~' | 'custom';
    value: string | number | boolean | Date | null | Array<string | number>;
}
export interface SortDef {
    field: string;
    direction?: 'asc' | 'desc' | 'ASC' | 'DESC';
    comparer?: (a: PrimitiveValue, b: PrimitiveValue) => number;
}
export interface SubSessionsMap {
    [name: string]: CreateSessionParameters;
}
export interface CreateSessionParameters {
    id?: string;
    table?: string | object;
    subSessions?: SubSessionsMap;
    columns?: ColumnDef[];
    filter?: FilterDef[];
    filters?: FilterDef[];
    sort?: SortDef[];
    sorts?: SortDef[];
    groupBy?: Array<string | {
        dataIndex: string;
    }>;
    includeLeafs?: boolean;
    limit?: number;
    offset?: number;
    permanentFilter?: FilterDef[];
}
export type SessionConfig = CreateSessionParameters;
export interface GroupNode<T = DataRow> {
    key: string;
    value: PrimitiveValue;
    children: GroupNode<T>[];
    data: T[];
    aggregates: {
        [key: string]: AggregateValue;
    };
    level: number;
}
export interface DataUpdate<T = DataRow> {
    removedData: T[];
    addedData: T[];
    removedIds: string[];
    addedIds: string[];
    updatedData?: T[];
    updatedIds?: string[];
}
export interface TesseractOptions {
    columns?: ColumnDef[];
    primaryKey?: string;
    defferedDataUpdateTime?: number;
    clusterSync?: boolean;
    id?: string;
    resolve?: (resolve: ResolveConfig, data: DataRow) => RowValue;
    persistent?: boolean;
}
export interface CommandPort {
    listen: (callback: () => void) => void;
    close: () => void;
}
export interface EventHorizonOptions {
    redis?: {
        host?: string;
        port?: number;
        password?: string;
        db?: number;
    };
    cluster?: boolean;
    clusterName?: string;
    namespace?: string;
    commandPort?: CommandPort;
}
export type EventCallback = (...args: PrimitiveValue[]) => void;
export type UnsubscribeFunction = () => void;
export type Comparer<T = PrimitiveValue> = (a: T, b: T) => number;
export type Predicate<T = DataRow> = (item: T) => boolean;
export type Aggregator<T = DataRow> = (items: T[], column?: string) => AggregateValue;
export interface GroupDataResult {
    key: string;
    value: PrimitiveValue;
    children?: GroupDataResult[];
    data?: DataRow[];
    aggregates?: {
        [key: string]: AggregateValue;
    };
    level?: number;
}
export interface UpdateResult {
    addedIds: IdValue[];
    addedData: DataRow[];
    updatedIds: IdValue[];
    updatedData: DataRow[];
    updateReason: string;
    removedIds: IdValue[];
    removedData: DataRow[];
    toJSON(): {
        addedIds: IdValue[];
        addedData: DataRow[];
        updatedIds: IdValue[];
        updatedData: DataRow[];
        updateReason: string;
        removedIds: IdValue[];
        removedData: DataRow[];
    };
}
